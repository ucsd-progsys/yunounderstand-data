{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> if name == k number else assoc (d, k, tail)","min":"","type":"syntax","out":"Characters 93-97:\n  | (name, number)::tail -> if name == k number else assoc (d, k, tail);;\n                                                ^^^^\nError: Syntax error\n"}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> if name == k number else assoc (d, k, tail)"],"region":{"start":0,"stop":992},"type":"eval"},"cursor":995,"time":1.444876754650747e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> if name == k number else assoc (d, k, tail)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> if name = k number else assoc (d, k, tail)","min":"","type":"syntax","out":"Characters 92-96:\n  | (name, number)::tail -> if name = k number else assoc (d, k, tail);;\n                                               ^^^^\nError: Syntax error\n"}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> if name = k number else assoc (d, k, tail)"],"region":{"start":0,"stop":991},"type":"eval"},"cursor":967,"time":1.444876767690618e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> if name = k number else assoc (d, k, tail)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> if name = k then number else assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> if name = k then number else assoc (d, k, tail)"],"region":{"start":0,"stop":996},"type":"eval"},"cursor":966,"time":1.444876775289557e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> if name = k then number else assoc (d, k, tail)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""}],"event":{"phrases":["","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"],"region":{"start":996,"stop":1073},"type":"eval"},"cursor":1079,"time":1.444876786500084e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> if name = k then number else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""}],"event":{"phrases":["","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"],"region":{"start":1073,"stop":1148},"type":"eval"},"cursor":1129,"time":1.444876789006673e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> if name = k then number else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if mem h seen then seen else h :: seen\nin let rest' = t\nin \nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"scope","out":"Characters 112-115:\n  let seen' = if mem h seen then seen else h :: seen\n                 ^^^\nError: Unbound value mem\n"}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if mem h seen then seen else h :: seen\nin let rest' = t\nin \nhelper (seen',rest')\nin\nList.rev (helper ([],l))"],"region":{"start":0,"stop":1869},"type":"eval"},"cursor":1869,"time":1.44487733278062e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::t -> \n          let seen' = if mem h seen then seen else h :: seen\n          in let rest' = t\n          in \n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen\nin let rest' = t\nin \nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen\nin let rest' = t\nin \nhelper (seen',rest')\nin\nList.rev (helper ([],l))"],"region":{"start":1151,"stop":1874},"type":"eval"},"cursor":1874,"time":1.444877342491558e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::t -> \n          let seen' = if List.mem h seen then seen else h :: seen\n          in let rest' = t\n          in \n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1874,"stop":1922},"type":"eval"},"cursor":1884,"time":1.444877355140933e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::t -> \n          let seen' = if List.mem h seen then seen else h :: seen\n          in let rest' = t\n          in \n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))"],"region":{"start":1151,"stop":1863},"type":"eval"},"cursor":1811,"time":1.444877387937474e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1863,"stop":1911},"type":"eval"},"cursor":1913,"time":1.444877391119804e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""}],"event":{"phrases":["","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'"],"region":{"start":1911,"stop":2450},"type":"eval"},"cursor":2450,"time":1.444877624341228e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2450,"stop":2514},"type":"eval"},"cursor":2516,"time":1.444877631981701e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2456,"stop":2515},"type":"eval"},"cursor":2517,"time":1.444877774951229e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""}],"event":{"phrases":["let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'"],"region":{"start":2372,"stop":2450},"type":"eval"},"cursor":2413,"time":1.44487777628909e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2450,"stop":2515},"type":"eval"},"cursor":2474,"time":1.444877777822629e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet f' b = (f b = b)\nin\nwwhile (f',b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = (f b) = b in wwhile (f', b);;\n","type":"type","out":"Characters 54-56:\n  wwhile (f',b);;\n          ^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"}],"event":{"phrases":["","let fixpoint (f,b) = \nlet f' b = (f b = b)\nin\nwwhile (f',b)"],"region":{"start":2515,"stop":2984},"type":"eval"},"cursor":2984,"time":1.444877936474328e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let f' b = (f b = b)\n  in\n    wwhile (f',b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet f' b = ( (f b) = b)\nin\nwwhile (f',b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = (f b) = b in wwhile (f', b);;\n","type":"type","out":"Characters 57-59:\n  wwhile (f',b);;\n          ^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"}],"event":{"phrases":["","let fixpoint (f,b) = \nlet f' b = ( (f b) = b)\nin\nwwhile (f',b)"],"region":{"start":2515,"stop":2987},"type":"eval"},"cursor":2961,"time":1.444877951814128e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let f' b = ( (f b) = b)\n  in\n    wwhile (f',b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet fb = f b\nin\nlet \nin\nwwhile (fb,b)","min":"","type":"syntax","out":"Characters 43-45:\n  in\n  ^^\nError: Syntax error\n"}],"event":{"phrases":["","let fixpoint (f,b) = \nlet fb = f b\nin\nlet \nin\nwwhile (fb,b)"],"region":{"start":2515,"stop":2984},"type":"eval"},"cursor":2984,"time":1.444878018680538e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let fb = f b\n  in\n  let \n  in\n    wwhile (fb,b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet fb = f b\nin\nwwhile (fb,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fb = f b in wwhile (fb, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = \nlet fb = f b\nin\nwwhile (fb,b)"],"region":{"start":2515,"stop":2976},"type":"eval"},"cursor":2962,"time":1.444878023661936e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let fb = f b\n  in\n    wwhile (fb,b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fb = f b in wwhile (fb, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"],"region":{"start":2976,"stop":3047},"type":"eval"},"cursor":2988,"time":1.444878033463724e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let fb = f b\n  in\n    wwhile (fb,b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet fb = f b\nin\nwwhile (fb,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fb = f b in wwhile (fb, b);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet fb = f b\nin\nwwhile (fb,b)"],"region":{"start":0,"stop":2976},"type":"eval"},"cursor":2935,"time":1.444967247936607e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let fb = f b\n  in\n    wwhile (fb,b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpointHelper b = \nif","min":"","type":"syntax","out":"Characters 26-28:\n  if;;\n    ^^\nError: Syntax error\n"},{"in":"let fixpoint (f,b) =\nlet helper b =\nif (f b = b) then\n(true, f b )\nelse\n(false, f b)\nin\nwwhile ( helper ,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = if (f b) = b then (true, (f b)) else (false, (f b)) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpointHelper b = \nif","let fixpoint (f,b) =\nlet helper b =\nif (f b = b) then\n(true, f b )\nelse\n(false, f b)\nin\nwwhile ( helper ,b)"],"region":{"start":2515,"stop":3065},"type":"eval"},"cursor":3041,"time":1.444967574673027e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpointHelper b = \n  if \n;;\n\nlet fixpoint (f,b) =\n  let helper b =\n    if (f b = b) then\n      (true, f b )\n    else\n      (false, f b)\n  in\n    wwhile ( helper ,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nif (f b = b) then\n(true, f b )\nelse\n(false, f b)\nin\nwwhile ( helper ,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = if (f b) = b then (true, (f b)) else (false, (f b)) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nif (f b = b) then\n(true, f b )\nelse\n(false, f b)\nin\nwwhile ( helper ,b)"],"region":{"start":2515,"stop":3033},"type":"eval"},"cursor":2936,"time":1.444967588583147e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    if (f b = b) then\n      (true, f b )\n    else\n      (false, f b)\n  in\n    wwhile ( helper ,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b) \nin\nif fb = b then\n(true, fb )\nelse\n(false, fb)\nin\nwwhile ( helper ,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b) \nin\nif fb = b then\n(true, fb )\nelse\n(false, fb)\nin\nwwhile ( helper ,b)"],"region":{"start":2515,"stop":3047},"type":"eval"},"cursor":2947,"time":1.4449676765891e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = (f b) \n    in\n      if fb = b then\n        (true, fb )\n      else\n        (false, fb)\n  in\n    wwhile ( helper ,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b) \nin\nif fb = b then\n(true, fb )\nelse\n(false, fb)\nin\nwwhile (helper ,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b) \nin\nif fb = b then\n(true, fb )\nelse\n(false, fb)\nin\nwwhile (helper ,b)"],"region":{"start":2515,"stop":3046},"type":"eval"},"cursor":3036,"time":1.444967687738739e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = (f b) \n    in\n      if fb = b then\n        (true, fb )\n      else\n        (false, fb)\n  in\n    wwhile (helper ,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b) \nin\nif fb = b then\n(true, fb)\nelse\n(false, fb)\nin\nwwhile (helper ,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 3);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 48);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 107);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b) \nin\nif fb = b then\n(true, fb)\nelse\n(false, fb)\nin\nwwhile (helper ,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2515,"stop":3372},"type":"eval"},"cursor":3376,"time":1.444967747628157e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = (f b) \n    in\n      if fb = b then\n        (true, fb)\n      else\n        (false, fb)\n  in\n    wwhile (helper ,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b = (true, b)\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let helper b = (true, b) in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b = (true, b)\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":2992},"type":"eval"},"cursor":2971,"time":1.444967779785305e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b = (true, b)\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b = (true, f b)\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let helper b = (true, (f b)) in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b = (true, f b)\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":2994},"type":"eval"},"cursor":2971,"time":1.444967808463292e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b = (true, f b)\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b = (true, (f b) )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let helper b = (true, (f b)) in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b = (true, (f b) )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":2997},"type":"eval"},"cursor":2975,"time":1.444967815541854e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b = (true, (f b) )\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b = \nf b\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let helper b = f b in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b = \nf b\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":2987},"type":"eval"},"cursor":2966,"time":1.444967883401255e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b = \n    f b\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet fb = f b\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fb = f b in wwhile (helper, b);;\n","type":"scope","out":"Characters 45-51:\n  wwhile (helper,b);;\n          ^^^^^^\nError: Unbound value helper\n"}],"event":{"phrases":["","let fixpoint (f,b) =\nlet fb = f b\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":2980},"type":"eval"},"cursor":2956,"time":1.444967897938269e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let fb = f b\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet fb = f b\nin\nwwhile (fb,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fb = f b in wwhile (fb, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet fb = f b\nin\nwwhile (fb,b)"],"region":{"start":2515,"stop":2976},"type":"eval"},"cursor":2973,"time":1.444967903096118e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let fb = f b\n  in\n    wwhile (fb,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper f b = \n( (f b) = b, f b )\nin\nwwhile (fb,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let helper f b = (((f b) = b), (f b)) in wwhile (fb, b);;\n","type":"scope","out":"Characters 69-71:\n  wwhile (fb,b);;\n          ^^\nError: Unbound value fb\n"}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper f b = \n( (f b) = b, f b )\nin\nwwhile (fb,b)"],"region":{"start":2515,"stop":3000},"type":"eval"},"cursor":2980,"time":1.44496801687024e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper f b = \n    ( (f b) = b, f b )\n  in\n    wwhile (fb,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper f b = \n( (f b) = b, f b )\nin\nwwhile (helper f b,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper f b = (((f b) = b), (f b)) in wwhile ((helper f b), b);;\n","type":"type","out":"Characters 69-79:\n  wwhile (helper f b,b);;\n          ^^^^^^^^^^\nError: This expression has type bool * 'a\n       but an expression was expected of type 'b -> 'b * bool\n"}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper f b = \n( (f b) = b, f b )\nin\nwwhile (helper f b,b)"],"region":{"start":2515,"stop":3008},"type":"eval"},"cursor":3005,"time":1.444968023600165e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper f b = \n    ( (f b) = b, f b )\n  in\n    wwhile (helper f b,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b = ( (f b) = b, (f b) )\nin\nwwhile (helper b,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = (((f b) = b), (f b)) in wwhile ((helper b), b);;\n","type":"type","out":"Characters 68-76:\n  wwhile (helper b,b);;\n          ^^^^^^^^\nError: This expression has type bool * 'a\n       but an expression was expected of type 'b -> 'b * bool\n"}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b = ( (f b) = b, (f b) )\nin\nwwhile (helper b,b)"],"region":{"start":2515,"stop":3005},"type":"eval"},"cursor":2976,"time":1.444968126018888e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b = ( (f b) = b, (f b) )\n  in\n    wwhile (helper b,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = f b \nin\nif fb = b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper b,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile ((helper b), b);;\n","type":"type","out":"Characters 111-119:\n  wwhile (helper b,b);;\n          ^^^^^^^^\nError: This expression has type bool * 'a\n       but an expression was expected of type 'b -> 'b * bool\n"}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = f b \nin\nif fb = b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper b,b)"],"region":{"start":2515,"stop":3048},"type":"eval"},"cursor":3025,"time":1.444968180675272e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = f b \n    in\n      if fb = b\n      then ( true, fb )\n      else ( false, fb )\n  in\n    wwhile (helper b,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = f b \nin\nif fb = b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = f b \nin\nif fb = b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3046},"type":"eval"},"cursor":3043,"time":1.444968190201344e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = f b \n    in\n      if fb = b\n      then ( true, fb )\n      else ( false, fb )\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 3);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 48);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 107);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3046,"stop":3373},"type":"eval"},"cursor":3376,"time":1.444968199820882e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = f b \n    in\n      if fb = b\n      then ( true, fb )\n      else ( false, fb )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = f b \nin\nif fb == b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb == b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = f b \nin\nif fb == b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3047},"type":"eval"},"cursor":2987,"time":1.444968235966487e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = f b \n    in\n      if fb == b\n      then ( true, fb )\n      else ( false, fb )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b)\nin\nif fb == b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb == b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) =\nlet helper b =\nlet fb = (f b)\nin\nif fb == b\nthen ( true, fb )\nelse ( false, fb )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3048},"type":"eval"},"cursor":2983,"time":1.444968261277274e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet fixpoint (f,b) =\n  let helper b =\n    let fb = (f b)\n    in\n      if fb == b\n      then ( true, fb )\n      else ( false, fb )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nif f a = a\nthen ( true, f a )\nelse ( false, f a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = if (f a) = a then (true, (f a)) else (false, (f a)) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nif f a = a\nthen ( true, f a )\nelse ( false, f a )\nin\nwwhile (helper,b)"],"region":{"start":0,"stop":3033},"type":"eval"},"cursor":3036,"time":1.444973658439157e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    if f a = a\n    then ( true, f a )\n    else ( false, f a )\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet helper a = \nif f a == a\nthen ( true, f a )\nelse ( false, f a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = if (f a) == a then (true, (f a)) else (false, (f a)) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = \nlet helper a = \nif f a == a\nthen ( true, f a )\nelse ( false, f a )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3034},"type":"eval"},"cursor":3034,"time":1.444973768147364e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    if f a == a\n    then ( true, f a )\n    else ( false, f a )\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet result = f b in\nlet helper a = ( result, result = b )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = \nlet result = f b in\nlet helper a = ( result, result = b )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3025},"type":"eval"},"cursor":3025,"time":1.444973946363477e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let result = f b in\n  let helper a = ( result, result = b )\n  in\n    wwhile (helper,b)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  let helper a = (result, (result = b)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3025,"stop":3352},"type":"eval"},"cursor":3355,"time":1.444973954725018e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let result = f b in\n  let helper a = ( result, result = b )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":2966,"time":1.444974013570535e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let result = f b in\n  let helper a = ( result, result = b )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet helper a = ( f a, (f a) = a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) = a)) in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = \nlet helper a = ( f a, (f a) = a )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3001},"type":"eval"},"cursor":3001,"time":1.444974060618895e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) = a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) = a)) in wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"],"region":{"start":3001,"stop":3074},"type":"eval"},"cursor":3045,"time":1.444974065528139e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) = a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""}],"event":{"phrases":["","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"],"region":{"start":3074,"stop":3157},"type":"eval"},"cursor":3118,"time":1.444974067121846e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) = a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) = a)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""}],"event":{"phrases":["","let _ = fixpoint (collatz, 1)"],"region":{"start":3157,"stop":3190},"type":"eval"},"cursor":3193,"time":1.444974070321951e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) = a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":2980,"time":1.444974087251221e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) = a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet helper a = ( f a, (f a) != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = \nlet helper a = ( f a, (f a) != a )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3002},"type":"eval"},"cursor":3002,"time":1.444974091062489e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = ((f a), ((f a) != a)) in wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3002,"stop":3329},"type":"eval"},"cursor":3332,"time":1.444974095409623e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = ( f a, (f a) != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)"],"region":{"start":2515,"stop":3027},"type":"eval"},"cursor":3000,"time":1.444974203161635e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3027,"stop":3354},"type":"eval"},"cursor":3357,"time":1.444974213757846e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = failwith \"to be written\"","min":"\nlet rec exprToString e = failwith \"to be written\";;\n","type":"","out":""}],"event":{"phrases":["","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = failwith \"to be written\""],"region":{"start":3354,"stop":3967},"type":"eval"},"cursor":3967,"time":1.44497428005491e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine * rest -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine * rest ->\n| Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n| Times -> expr1 ^ \"*\" ^ expr2\n| Thresh -> \"(\" ^ expr1 ^ \"<\" ^ expr2 ^ \"?\" ^ expr3 ^ \":\" ^ exprToString expr4 ^ \")\"","min":"","type":"syntax","out":"Characters 73-74:\n  | Sine * rest -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n         ^\nError: Syntax error\n"}],"event":{"phrases":["","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine * rest -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine * rest ->\n| Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n| Times -> expr1 ^ \"*\" ^ expr2\n| Thresh -> \"(\" ^ expr1 ^ \"<\" ^ expr2 ^ \"?\" ^ expr3 ^ \":\" ^ exprToString expr4 ^ \")\""],"region":{"start":3824,"stop":4218},"type":"eval"},"cursor":4218,"time":1.4449749704874e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine * rest -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n  | Cosine * rest ->\n  | Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n  | Times -> expr1 ^ \"*\" ^ expr2\n  | Thresh -> \"(\" ^ expr1 ^ \"<\" ^ expr2 ^ \"?\" ^ expr3 ^ \":\" ^ exprToString expr4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest) ->\n| Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n| Times -> expr1 ^ \"*\" ^ expr2\n| Thresh -> \"(\" ^ expr1 ^ \"<\" ^ expr2 ^ \"?\" ^ expr3 ^ \":\" ^ exprToString expr4 ^ \")\"","min":"","type":"syntax","out":"Characters 139-140:\n  | Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n  ^\nError: Syntax error\n"}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest) ->\n| Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n| Times -> expr1 ^ \"*\" ^ expr2\n| Thresh -> \"(\" ^ expr1 ^ \"<\" ^ expr2 ^ \"?\" ^ expr3 ^ \":\" ^ exprToString expr4 ^ \")\""],"region":{"start":0,"stop":4218},"type":"eval"},"cursor":4037,"time":1.444975124693835e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest) ->\n  | Average -> \"(\" ^ expr1 ^ \"+\" ^ expr2 ^\"/2)\"\n  | Times -> expr1 ^ \"*\" ^ expr2\n  | Thresh -> \"(\" ^ expr1 ^ \"<\" ^ expr2 ^ \"?\" ^ expr3 ^ \":\" ^ exprToString expr4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \"?\" ^ exprToString expr3 ^ \":\" ^ exprToString expr4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))));;\n","type":"type","out":"Characters 338-344:\n  | Thresh -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \"?\" ^ exprToString expr3 ^ \":\" ^ exprToString expr4 ^ \")\";;\n    ^^^^^^\nError: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n"}],"event":{"phrases":["","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \"?\" ^ exprToString expr3 ^ \":\" ^ exprToString expr4 ^ \")\""],"region":{"start":3824,"stop":4377},"type":"eval"},"cursor":4377,"time":1.444975189263113e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \"?\" ^ exprToString expr3 ^ \":\" ^ exprToString expr4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\""],"region":{"start":3824,"stop":4383},"type":"eval"},"cursor":4383,"time":1.444975218503226e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""}],"event":{"phrases":["","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))"],"region":{"start":4383,"stop":4561},"type":"eval"},"cursor":4509,"time":1.444975233100161e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let _ = exprToString sampleExpr1"],"region":{"start":4561,"stop":4598},"type":"eval"},"cursor":4591,"time":1.444975235399622e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest) -> \"sin(pi\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest) -> \"cos(pi\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2) -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2) -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\""],"region":{"start":3824,"stop":4411},"type":"eval"},"cursor":4411,"time":1.444975282906419e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1"],"region":{"start":4411,"stop":4626},"type":"eval"},"cursor":4627,"time":1.444975287524367e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> x","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> x;;\n","type":"type","out":"Characters 234-235:\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2\n                                                                   ^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"phrases":["","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> x"],"region":{"start":4626,"stop":5614},"type":"eval"},"cursor":5614,"time":1.44497583262439e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> x\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> x","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> x;;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> x"],"region":{"start":5206,"stop":5615},"type":"eval"},"cursor":5526,"time":1.444975847322897e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> x\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)"],"region":{"start":5206,"stop":5681},"type":"eval"},"cursor":5681,"time":1.444975996070196e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\n"}],"event":{"phrases":["","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5681,"stop":5821},"type":"eval"},"cursor":5823,"time":1.444976003929395e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":5785,"stop":5822},"type":"eval"},"cursor":5813,"time":1.444976020443695e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) >= eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) >= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) >= eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)"],"region":{"start":5206,"stop":5682},"type":"eval"},"cursor":5632,"time":1.444976060503748e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) >= eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) >= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) >= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) >= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":5682,"stop":5823},"type":"eval"},"cursor":5825,"time":1.444976063805588e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) >= eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <= eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <= (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <= eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":5206,"stop":5823},"type":"eval"},"cursor":5825,"time":1.444976082106676e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <= eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <. eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"scope","out":"Characters 340-342:\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <. eval(e2,x,y) \n                                               ^^\nError: Unbound value <.\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <. eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)"],"region":{"start":5206,"stop":5682},"type":"eval"},"cursor":5682,"time":1.444976115884752e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) <. eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"],"region":{"start":5206,"stop":6357},"type":"eval"},"cursor":6357,"time":1.444976135416407e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":6357,"stop":6494},"type":"eval"},"cursor":6496,"time":1.444976171821861e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":6457,"stop":6493},"type":"eval"},"cursor":6484,"time":1.444976175411637e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"","type":"scope","out":"Error: Unbound value emitGrayscale\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-21:\n  let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\");;\n          ^^^^^^^^^^^^^\nError: Unbound value emitGrayscale\n"}],"event":{"phrases":["","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"],"region":{"start":6493,"stop":6554},"type":"eval"},"cursor":6557,"time":1.444976300926858e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0) then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> VarX\n| 1 -> VarY\nelse\nVarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let result = rand (0, 1) in match result with | 0 -> VarX | 1 -> VarY\n  else VarX;;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif (depth = 0) then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> VarX\n| 1 -> VarY\nelse\nVarX"],"region":{"start":0,"stop":6973},"type":"eval"},"cursor":6973,"time":1.444980056821397e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0) then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> VarX\n        | 1 -> VarY\n  else\n    VarX\n\n\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif (depth = 0) then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY()\nelse\nlet result = rand(0,4) in\nmatch result with\n| 0 -> buildSine( build(rand, depth - 1) )\n| 1 -> buildCosine( build(rand, depth - 1) )\n| 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n| 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n| 4 -> buildTresh( build(rand, depth - 1), build(rand, depth -1),\nbuild(rand, depth - 1), build(rand, depth -1) )\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     match result with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n","type":"scope","out":"Characters 409-419:\n  | 4 -> buildTresh( build(rand, depth - 1), build(rand, depth -1),\n         ^^^^^^^^^^\nError: Unbound value buildTresh\n"}],"event":{"phrases":["","let rec build (rand, depth) = \nif (depth = 0) then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY()\nelse\nlet result = rand(0,4) in\nmatch result with\n| 0 -> buildSine( build(rand, depth - 1) )\n| 1 -> buildCosine( build(rand, depth - 1) )\n| 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n| 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n| 4 -> buildTresh( build(rand, depth - 1), build(rand, depth -1),\nbuild(rand, depth - 1), build(rand, depth -1) )\n| _ -> buildX()"],"region":{"start":6493,"stop":7375},"type":"eval"},"cursor":7376,"time":1.444980306947713e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0) then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY()\n  else\n    let result = rand(0,4) in\n      match result with\n        | 0 -> buildSine( build(rand, depth - 1) )\n        | 1 -> buildCosine( build(rand, depth - 1) )\n        | 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n        | 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n        | 4 -> buildTresh( build(rand, depth - 1), build(rand, depth -1),\n                           build(rand, depth - 1), build(rand, depth -1) )\n        | _ -> buildX()\n\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif (depth = 0) then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY()\nelse\nlet result = rand(0,4) in\nmatch result with\n| 0 -> buildSine( build(rand, depth - 1) )\n| 1 -> buildCosine( build(rand, depth - 1) )\n| 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n| 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n| 4 -> buildThresh( build(rand, depth - 1), build(rand, depth -1),\nbuild(rand, depth - 1), build(rand, depth -1) )\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     match result with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif (depth = 0) then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY()\nelse\nlet result = rand(0,4) in\nmatch result with\n| 0 -> buildSine( build(rand, depth - 1) )\n| 1 -> buildCosine( build(rand, depth - 1) )\n| 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n| 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n| 4 -> buildThresh( build(rand, depth - 1), build(rand, depth -1),\nbuild(rand, depth - 1), build(rand, depth -1) )\n| _ -> buildX()"],"region":{"start":6493,"stop":7376},"type":"eval"},"cursor":7376,"time":1.444980329420418e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0) then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY()\n  else\n    let result = rand(0,4) in\n      match result with\n        | 0 -> buildSine( build(rand, depth - 1) )\n        | 1 -> buildCosine( build(rand, depth - 1) )\n        | 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n        | 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n        | 4 -> buildThresh( build(rand, depth - 1), build(rand, depth -1),\n                            build(rand, depth - 1), build(rand, depth -1) )\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     match result with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     match result with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""}],"event":{"phrases":["","let g1 () = failwith \"to be implemented\"","let g2 () = failwith \"to be implemented\"","let g3 () = failwith \"to be implemented\"","let c1 () = failwith \"to be implemented\"","let c2 () = failwith \"to be implemented\"","let c3 () = failwith \"to be implemented\"","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"],"region":{"start":7376,"stop":13321},"type":"eval"},"cursor":13321,"time":1.444980401447269e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0) then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY()\n  else\n    let result = rand(0,4) in\n      match result with\n        | 0 -> buildSine( build(rand, depth - 1) )\n        | 1 -> buildCosine( build(rand, depth - 1) )\n        | 2 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1) )\n        | 3 -> buildTimes( build(rand, depth - 1), build(rand, depth -1) )\n        | 4 -> buildThresh( build(rand, depth - 1), build(rand, depth -1),\n                            build(rand, depth - 1), build(rand, depth -1) )\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) =","min":"","type":"syntax","out":"Characters 29-31:\n  let rec build (rand, depth) =;;\n                               ^^\nError: Syntax error\n"},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"","type":"type","out":"Error: This expression has type expr/1869\n       but an expression was expected of type expr/2092\nError: This expression has type expr/2229\n       but an expression was expected of type expr/2197\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/1869\n       but an expression was expected of type expr/2092\n"},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"","type":"type","out":"Error: This expression has type expr/1869\n       but an expression was expected of type expr/2092\nError: This expression has type expr/2362\n       but an expression was expected of type expr/2330\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 216-218:\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n                                                      ^^\nError: This expression has type expr/1869\n       but an expression was expected of type expr/2092\n"},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) =","let g1 () = failwith \"to be implemented\"","let g2 () = failwith \"to be implemented\"","let g3 () = failwith \"to be implemented\"","let c1 () = failwith \"to be implemented\"","let c2 () = failwith \"to be implemented\"","let c3 () = failwith \"to be implemented\"","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]"],"region":{"start":0,"stop":16188},"type":"eval"},"cursor":14956,"time":1.445043351360914e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildTresh(build1, build2, build3, build4)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildTresh (build1, build2, build3, build4));;\n","type":"scope","out":"Characters 462-472:\n  | 4 -> buildTresh(build1, build2, build3, build4);;\n         ^^^^^^^^^^\nError: Unbound value buildTresh\n"}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildTresh(build1, build2, build3, build4)"],"region":{"start":0,"stop":7348},"type":"eval"},"cursor":7229,"time":1.445043681212288e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildTresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)"],"region":{"start":6493,"stop":7349},"type":"eval"},"cursor":7313,"time":1.445043692466549e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""}],"event":{"phrases":["","let g1 () = failwith \"to be implemented\"","let g2 () = failwith \"to be implemented\"","let g3 () = failwith \"to be implemented\"","let c1 () = failwith \"to be implemented\"","let c2 () = failwith \"to be implemented\"","let c3 () = failwith \"to be implemented\"","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"],"region":{"start":7349,"stop":10867},"type":"eval"},"cursor":10868,"time":1.445043707758958e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""}],"event":{"phrases":["","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"],"region":{"start":10867,"stop":10927},"type":"eval"},"cursor":10910,"time":1.445043710373245e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n","type":"","out":""},{"in":"let g1 () = (20, 5, 123)","min":"\nlet g1 () = (20, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (17, 57, 28)","min":"\nlet g2 () = (17, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (100, 100000, 999999)","min":"\nlet g3 () = (100, 100000, 999999);;\n","type":"","out":""},{"in":"let c1 () = (66, 5555, 13)","min":"\nlet c1 () = (66, 5555, 13);;\n","type":"","out":""},{"in":"let c2 () = (494, 7241996, 11341994)","min":"\nlet c2 () = (494, 7241996, 11341994);;\n","type":"","out":""},{"in":"let c3 () = (96, 123, 4908)","min":"\nlet c3 () = (96, 123, 4908);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)","let g1 () = (20, 5, 123)","let g2 () = (17, 57, 28)","let g3 () = (100, 100000, 999999)","let c1 () = (66, 5555, 13)","let c2 () = (494, 7241996, 11341994)","let c3 () = (96, 123, 4908)"],"region":{"start":0,"stop":7734},"type":"eval"},"cursor":7720,"time":1.445044445717998e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (100, 100000, 999999) \n\nlet c1 () = (66, 5555, 13)\nlet c2 () = (494, 7241996, 11341994)\nlet c3 () = (96, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let c3 () = (96, 123, 4908)","min":"\nlet c3 () = (96, 123, 4908);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let c3 () = (96, 123, 4908)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7707,"stop":16867},"type":"eval"},"cursor":7720,"time":1.445044454157188e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (100, 100000, 999999) \n\nlet c1 () = (66, 5555, 13)\nlet c2 () = (494, 7241996, 11341994)\nlet c3 () = (96, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":6843,"time":1.44504450926129e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (100, 100000, 999999) \n\nlet c1 () = (66, 5555, 13)\nlet c2 () = (494, 7241996, 11341994)\nlet c3 () = (96, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7716,"time":1.445044523433115e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (10, 100000, 999999) \n\nlet c1 () = (6, 5555, 13)\nlet c2 () = (4, 7241996, 11341994)\nlet c3 () = (6, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7716,"time":1.445044524391521e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (10, 100000, 999999) \n\nlet c1 () = (6, 5555, 13)\nlet c2 () = (4, 7241996, 11341994)\nlet c3 () = (6, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7716,"time":1.44504452485917e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (10, 100000, 999999) \n\nlet c1 () = (6, 5555, 13)\nlet c2 () = (4, 7241996, 11341994)\nlet c3 () = (6, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7716,"time":1.445044525135609e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (10, 100000, 999999) \n\nlet c1 () = (6, 5555, 13)\nlet c2 () = (4, 7241996, 11341994)\nlet c3 () = (6, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7716,"time":1.44504452533969e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (10, 100000, 999999) \n\nlet c1 () = (6, 5555, 13)\nlet c2 () = (4, 7241996, 11341994)\nlet c3 () = (6, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g3 () = (10, 100000, 999999)","min":"\nlet g3 () = (10, 100000, 999999);;\n","type":"","out":""},{"in":"let c1 () = (6, 5555, 13)","min":"\nlet c1 () = (6, 5555, 13);;\n","type":"","out":""},{"in":"let c2 () = (4, 7241996, 11341994)","min":"\nlet c2 () = (4, 7241996, 11341994);;\n","type":"","out":""},{"in":"let c3 () = (6, 123, 4908)","min":"\nlet c3 () = (6, 123, 4908);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let g3 () = (10, 100000, 999999)","let c1 () = (6, 5555, 13)","let c2 () = (4, 7241996, 11341994)","let c3 () = (6, 123, 4908)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7606,"stop":16862},"type":"eval"},"cursor":7716,"time":1.445044528283446e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (20, 5, 123)\nlet g2 () = (17, 57, 28)\nlet g3 () = (10, 100000, 999999) \n\nlet c1 () = (6, 5555, 13)\nlet c2 () = (4, 7241996, 11341994)\nlet c3 () = (6, 123, 4908)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7674,"time":1.445044576130012e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7349,"time":1.445044608769887e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7349,"time":1.445044609265521e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7349,"time":1.445044609776796e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7349,"time":1.445044610250077e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7349,"time":1.445044610749955e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()"],"region":{"start":6493,"stop":7365},"type":"eval"},"cursor":7365,"time":1.445044623028028e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g1 () = (1, 5, 123)","min":"\nlet g1 () = (1, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (2, 57, 28)","min":"\nlet g2 () = (2, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (3, 100, 999)","min":"\nlet g3 () = (3, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (4, 55, 13)","min":"\nlet c1 () = (4, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (3, 123, 498)","min":"\nlet c3 () = (3, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let g1 () = (1, 5, 123)","let g2 () = (2, 57, 28)","let g3 () = (3, 100, 999)","let c1 () = (4, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (3, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7365,"stop":16856},"type":"eval"},"cursor":7723,"time":1.445044626007393e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = match e with\n  | VarX -> \"x\"\n  | VarY -> \"y\"\n  | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n  | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n  | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n  | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n  | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                               ^ \":\" ^ exprToString e4 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (3, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (10, 5, 123)","min":"\nlet g1 () = (10, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (12, 57, 28)","min":"\nlet g2 () = (12, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (6, 55, 13)","min":"\nlet c1 () = (6, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (8, 123, 498)","min":"\nlet c3 () = (8, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (10, 5, 123)","let g2 () = (12, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (6, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (8, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":0,"stop":16940},"type":"eval"},"cursor":7796,"time":1.44505048755625e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Sqrt     of expr \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr \n| \n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","min":"","type":"syntax","out":"Characters 181-184:\n  let rec exprToString e = \n  ^^^\nError: Syntax error\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (10, 5, 123)","min":"\nlet g1 () = (10, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (12, 57, 28)","min":"\nlet g2 () = (12, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (6, 55, 13)","min":"\nlet c1 () = (6, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (8, 123, 498)\n\nexprToString","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet c3 () = (8, 123, 498) exprToString;;\n","type":"type","out":"Characters 12-25:\n  let c3 () = (8, 123, 498)\n              ^^^^^^^^^^^^^\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr \n| \n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (10, 5, 123)","let g2 () = (12, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (6, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (8, 123, 498)\n\nexprToString","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"],"region":{"start":0,"stop":13307},"type":"eval"},"cursor":13089,"time":1.445052358511345e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Sqrt     of expr \n    | \n\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n      let rec exprToString e = \n        match e with\n          | VarX -> \"x\"\n          | VarY -> \"y\"\n          | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n          | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n          | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n          | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n          | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                       ^ \":\" ^ exprToString e4 ^ \")\"\n          | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":13089,"time":1.445052362007614e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Sqrt     of expr \n    | \n\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n      let rec exprToString e = \n        match e with\n          | VarX -> \"x\"\n          | VarY -> \"y\"\n          | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n          | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n          | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n          | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n          | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                       ^ \":\" ^ exprToString e4 ^ \")\"\n          | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr \n| \n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","min":"","type":"syntax","out":"Characters 181-184:\n  let rec exprToString e = \n  ^^^\nError: Syntax error\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (10, 5, 123)","min":"\nlet g1 () = (10, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (12, 57, 28)","min":"\nlet g2 () = (12, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (6, 55, 13)","min":"\nlet c1 () = (6, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (8, 123, 498)\n\nexprToString","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet c3 () = (8, 123, 498) exprToString;;\n","type":"type","out":"Characters 12-25:\n  let c3 () = (8, 123, 498)\n              ^^^^^^^^^^^^^\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr \n| \n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (10, 5, 123)","let g2 () = (12, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (6, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (8, 123, 498)\n\nexprToString","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":3283,"stop":16958},"type":"eval"},"cursor":13089,"time":1.445052363299196e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Sqrt     of expr \n    | \n\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n      let rec exprToString e = \n        match e with\n          | VarX -> \"x\"\n          | VarY -> \"y\"\n          | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n          | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n          | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n          | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n          | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                       ^ \":\" ^ exprToString e4 ^ \")\"\n          | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""}],"event":{"phrases":["","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"],"region":{"start":3354,"stop":3824},"type":"eval"},"cursor":3825,"time":1.445052375808089e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n","type":"type","out":"Characters 497-501:\n  | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\";;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Sqrt does not belong to type expr\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"","type":"type","out":"NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 21-32:\n  let _ = exprToString sampleExpr1;;\n                       ^^^^^^^^^^^\nError: This expression has type expr/3709\n       but an expression was expected of type expr/3147\n"},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (10, 5, 123)","min":"\nlet g1 () = (10, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (12, 57, 28)","min":"\nlet g2 () = (12, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (6, 55, 13)","min":"\nlet c1 () = (6, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (8, 123, 498)\n\nexprToString","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n\nlet c3 () = (8, 123, 498) exprToString;;\n","type":"type","out":"Characters 12-25:\n  let c3 () = (8, 123, 498)\n              ^^^^^^^^^^^^^\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"","type":"type","out":"Error: This expression has type expr/3709\n       but an expression was expected of type expr/3147\nError: This variant pattern is expected to have type expr\n       The constructor Sqrt does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/3709\n       but an expression was expected of type expr/3147\n"},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"","type":"type","out":"Error: This expression has type expr/3709\n       but an expression was expected of type expr/3147\nError: This variant pattern is expected to have type expr\n       The constructor Sqrt does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 216-218:\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n                                                      ^^\nError: This expression has type expr/3709\n       but an expression was expected of type expr/3147\n"},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (10, 5, 123)","let g2 () = (12, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (6, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (8, 123, 498)\n\nexprToString","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":3670,"stop":16935},"type":"eval"},"cursor":3825,"time":1.445052377274762e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Sqrt (e1)               -> \"sqrt(\" ^ exprToString e1 ^ \")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\""],"region":{"start":3824,"stop":4412},"type":"eval"},"cursor":4413,"time":1.445052386034315e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (10, 5, 123)","min":"\nlet g1 () = (10, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (12, 57, 28)","min":"\nlet g2 () = (12, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (6, 55, 13)","min":"\nlet c1 () = (6, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (8, 123, 498)\n\nexprToString","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet c3 () = (8, 123, 498) exprToString;;\n","type":"type","out":"Characters 12-25:\n  let c3 () = (8, 123, 498)\n              ^^^^^^^^^^^^^\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (10, 5, 123)","let g2 () = (12, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (6, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (8, 123, 498)\n\nexprToString","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":3918,"stop":16875},"type":"eval"},"cursor":4413,"time":1.445052388355334e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (10, 5, 123)","min":"\nlet g1 () = (10, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (12, 57, 28)","min":"\nlet g2 () = (12, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (6, 55, 13)","min":"\nlet c1 () = (6, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (8, 123, 498)\n\nexprToString","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet c3 () = (8, 123, 498) exprToString;;\n","type":"type","out":"Characters 12-25:\n  let c3 () = (8, 123, 498)\n              ^^^^^^^^^^^^^\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (10, 5, 123)","let g2 () = (12, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (6, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (8, 123, 498)\n\nexprToString","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":0,"stop":16875},"type":"eval"},"cursor":912,"time":1.445052419556007e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n              exprToString \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let c3 () = (8, 123, 498)","min":"\nlet c3 () = (8, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let c3 () = (8, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7701,"stop":16861},"type":"eval"},"cursor":7728,"time":1.445052557270335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (10, 5, 123)\nlet g2 () = (12, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (8, 123, 498)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,5) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 5) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (1, 5, 123)","min":"\nlet g1 () = (1, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (2, 57, 28)","min":"\nlet g2 () = (2, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (3, 100, 999)","min":"\nlet g3 () = (3, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (4, 55, 13)","min":"\nlet c1 () = (4, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (6, 123, 498)","min":"\nlet c3 () = (6, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 5) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 5) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,5) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (1, 5, 123)","let g2 () = (2, 57, 28)","let g3 () = (3, 100, 999)","let c1 () = (4, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (6, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":6495,"stop":16859},"type":"eval"},"cursor":7351,"time":1.445052653611184e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (1, 5, 123)\nlet g2 () = (2, 57, 28)\nlet g3 () = (3, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n","type":"","out":""},{"in":"let g1 () = (9, 5, 123)","min":"\nlet g1 () = (9, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (10, 57, 28)","min":"\nlet g2 () = (10, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (4, 55, 13)","min":"\nlet c1 () = (4, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (6, 123, 498)","min":"\nlet c3 () = (6, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 4) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | _ -> buildX ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n| Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,1) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,4) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| _ -> buildX()","let g1 () = (9, 5, 123)","let g2 () = (10, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (4, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (6, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":0,"stop":16859},"type":"eval"},"cursor":6999,"time":1.445052917385998e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,1) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,4) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | _ -> buildX()\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,5) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| _ -> buildThresh(build1, build2, build3, build4)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 5) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | _ -> buildThresh (build1, build2, build3, build4));;\n","type":"","out":""},{"in":"let g1 () = (9, 5, 123)","min":"\nlet g1 () = (9, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (8, 57, 28)","min":"\nlet g2 () = (8, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (4, 55, 13)","min":"\nlet c1 () = (4, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (6, 123, 498)","min":"\nlet c3 () = (6, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 5) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | _ -> buildThresh (build1, build2, build3, build4));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 5) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | _ -> buildThresh (build1, build2, build3, build4));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,5) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| _ -> buildThresh(build1, build2, build3, build4)","let g1 () = (9, 5, 123)","let g2 () = (8, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (4, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (6, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":6495,"stop":16842},"type":"eval"},"cursor":7597,"time":1.445053015819855e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (expr1, expr2)  -> \"(\" ^ exprToString expr1 ^ \"+\" ^ exprToString expr2 ^ \"/2)\"\n    | Times (expr1, expr2)    -> exprToString expr1 ^ \"*\" ^ exprToString expr2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 \n                                 ^ \":\" ^ exprToString e4 ^ \")\"\n\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (8, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,number)::tail -> if name = k then number else assoc (d, k, tail);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::rest' ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let helper a = let result = f a in (result, (result != a)) in\n  wwhile (helper, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Arctan   of expr\n| Strange  of expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n| Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n| Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n\"(\" ^ exprToString e2 ^ \")^2 + \" ^\nexprToString e1 ^ \"*\" ^ exprToString e2 ^\n\") / 3\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"( (\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^\n                       ((exprToString e1) ^\n                          (\"*\" ^ ((exprToString e2) ^ \") / 3\"))))))));;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (name, number)::tail -> \nif name = k \nthen number \nelse assoc (d, k, tail)","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::rest' -> \nlet seen' = \nif List.mem h seen \nthen seen \nelse h :: seen\nin\nhelper (seen',rest')\nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) =\nlet (b', c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = \nlet helper a = \nlet result = f a in\n( result, result != a )\nin\nwwhile (helper,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Arctan   of expr\n| Strange  of expr * expr * expr","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n| Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n| Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n\"(\" ^ exprToString e2 ^ \")^2 + \" ^\nexprToString e1 ^ \"*\" ^ exprToString e2 ^\n\") / 3\""],"region":{"start":0,"stop":4663},"type":"eval"},"cursor":4663,"time":1.445055810253595e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 exprToString e1 ^ \"*\" ^ exprToString e2 ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n| Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n| Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n\"(\" ^ exprToString e2 ^ \")^2 + \" ^\n\"(\" ^ exprToString e3 ^ \")^2 + \" ^\n\") / 3\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"( (\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^\n                       (\"(\" ^ ((exprToString e3) ^ (\")^2 + \" ^ \") / 3\"))))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"( (\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^\n                       (\"(\" ^ ((exprToString e3) ^ (\")^2 + \" ^ \") / 3\"))))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2 * (atan eval(e1,x,y)) / pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) * eval(e1,x,y) + \neval(e2,x,y) * eval(e2,x,y) +\neval(e3,x,y) * eval(e3,x,y) ) /3","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2 * (atan eval (e1, x, y))) / pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) * (eval (e1, x, y))) +\n          ((eval (e2, x, y)) * (eval (e2, x, y))))\n         + ((eval (e3, x, y)) * (eval (e3, x, y))))\n        / 3;;\n","type":"type","out":"Characters 417-421:\n  | Arctan (e1)\t\t  -> 2 * (atan eval(e1,x,y)) / pi\n                           ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n| Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n| Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n\"(\" ^ exprToString e2 ^ \")^2 + \" ^\n\"(\" ^ exprToString e3 ^ \")^2 + \" ^\n\") / 3\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2 * (atan eval(e1,x,y)) / pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) * eval(e1,x,y) + \neval(e2,x,y) * eval(e2,x,y) +\neval(e3,x,y) * eval(e3,x,y) ) /3"],"region":{"start":3877,"stop":6100},"type":"eval"},"cursor":6100,"time":1.445056071281031e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> 2 * (atan eval(e1,x,y)) / pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) * eval(e1,x,y) + \n                                 eval(e2,x,y) * eval(e2,x,y) +\n                                 eval(e3,x,y) * eval(e3,x,y) ) /3\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) / pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2 *. (atan eval (e1, x, y))) / pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"type","out":"Characters 412-413:\n  | Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) / pi\n                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) / pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6108},"type":"eval"},"cursor":6108,"time":1.445056095699887e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) / pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2 *. (atan eval (e1, x, y))) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"type","out":"Characters 412-413:\n  | Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) /. pi\n                      ^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6109},"type":"eval"},"cursor":5974,"time":1.445056104652216e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> 2 *. (atan eval(e1,x,y)) /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2. *. (atan eval (e1, x, y))) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"type","out":"Characters 419-423:\n  | Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) /. pi\n                             ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6110},"type":"eval"},"cursor":5949,"time":1.445056123549478e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) ) /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2. *. (atan eval (e1, x, y))) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"type","out":"Characters 421-425:\n  | Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) ) /. pi\n                               ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) ) /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6114},"type":"eval"},"cursor":5974,"time":1.445056149480708e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) ) /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"","type":"syntax","out":"Characters 412-413:\n  | Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) \n                      ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6107},"type":"eval"},"cursor":5975,"time":1.445056167317654e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> ( 2. *. (atan eval(e1,x,y)) \n                      | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                                     eval(e2,x,y) *. eval(e2,x,y) +.\n                                                     eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n                        ;;\n\n\n                        let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n                        let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n                        let _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\n                        let eval_fn e (x,y) = \n                          let rv = eval (e,x,y) in\n                            assert (-1.0 <= rv && rv <= 1.0);\n                            rv\n\n                        let sampleExpr =\n                          buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                                                      buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                                                       (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                                           buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                                                 (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                                                   (buildX(),buildX()))))))),buildY())))\n\n                        let sampleExpr2 =\n                          buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n                        let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n                        let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n                        let _ = eval (sampleExpr,0.5,0.2);;\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        let rec build (rand, depth) = \n                          if depth = 0 then\n                            let result = rand(0,2) in\n                              match result with \n                                | 0 -> buildX()\n                                | _ -> buildY() \n                          else\n                            let result = rand(0,5) in\n                            let build1 = build(rand, depth - 1) in\n                            let build2 = build(rand, depth - 1) in\n                            let build3 = build(rand, depth - 1) in\n                            let build4 = build(rand, depth - 1) in\n                              match result with \n                                | 0 -> buildSine(build1)\n                                | 1 -> buildCosine(build1)\n                                | 2 -> buildAverage(build1, build2)\n                                | 3 -> buildTimes(build1, build2)\n                                | _ -> buildThresh(build1, build2, build3, build4)\n                        ;;\n\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        let g1 () = (9, 5, 123)\n                        let g2 () = (10, 57, 28)\n                        let g3 () = (7, 100, 999) \n\n                        let c1 () = (4, 55, 13)\n                        let c2 () = (5, 96, 194)\n                        let c3 () = (6, 123, 498)\n\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        *)\n\n                        let makeRand (seed1, seed2) = \n                          let seed = (Array.of_list [seed1;seed2]) in\n                          let s = Random.State.make seed in\n                            (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\n                        let rec rseq g r n =\n                          if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        let toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        let toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        let rec ffor (low,high,f) = \n                          if low > high then () else \n                            let _ = f low in \n                              ffor (low+1,high,f)\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        let emitGrayscale (f,n,name) =\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let fname  = (\"art_g_\"^name) in\n                          let chan = open_out (fname^\".pgm\") in\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let n2p1 = n*2+1 in   \n                          let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n                          let _ = \n                            ffor (-n, n, \n                                  fun ix ->\n                                    ffor (-n, n, \n                                          fun iy ->\n                                            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                            let x = toReal(ix,n) in\n                                            let y = toReal(iy,n) in\n                                            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                            let z = f (x,y) in\n                                            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                            let iz = toIntensity(z) in\n                                              (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                              output_char chan (char_of_int iz))) in \n                            close_out chan;\n                            ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n                            ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        let doRandomGray (depth,seed1,seed2) =\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let g = makeRand(seed1,seed2) in\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let e = build (g,depth) in\n                          let _ = print_string (exprToString e) in\n                          let f = eval_fn e in\n                          (*XXXXXXXXXXXXXXXXXX*)\n                          let n = 150 in\n                          (*XXXXXXXXXXXXXXXXXX*)\n                          let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n                            emitGrayscale (f,n,name)\n\n\n                        let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        let emitColor (f1,f2,f3,n,name) =\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let fname  = (\"art_c_\"^name) in\n                          let chan = open_out (fname^\".ppm\") in\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let n2p1 = n*2+1 in   \n                          let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n                          let _ = \n                            ffor (-n, n, \n                                  fun ix ->\n                                    ffor (-n, n, \n                                          fun iy ->\n                                            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                            let x = toReal(ix,n) in\n                                            let y = toReal(iy,n) in\n                                            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                            let z1 = f1 (x,y) in\n                                            let z2 = f2 (x,y) in\n                                            let z3 = f3 (x,y) in\n\n                                            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                            let iz1 = toIntensity(z1) in\n                                            let iz2 = toIntensity(z2) in\n                                            let iz3 = toIntensity(z3) in\n\n                                              (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                                              output_char chan (char_of_int iz1);\n                                              output_char chan (char_of_int iz2);\n                                              output_char chan (char_of_int iz3);\n                                         )) in  \n                            close_out chan;\n                            ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n                            ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        let doRandomColor (depth,seed1,seed2) =\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let g = makeRand (seed1,seed2) in\n                          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                          let e1 = build (g, depth) in\n                          let e2 = build (g, depth) in\n                          let e3 = build (g, depth) in\n\n                          let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n                          let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n                          let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n                          let f1 = eval_fn e1 in\n                          let f2 = eval_fn e2 in\n                          let f3 = eval_fn e3 in\n\n                          (*XXXXXXXXXXXXXXXXXX*)\n                          let n = 150 in\n                          (*XXXXXXXXXXXXXXXXXX*)\n                          let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n                            emitColor (f1,f2,f3,n,name)\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                        type test = unit -> string\n\n                        let key = \"\" (*XXXXXXXX*)\n                        let prefix130 = \"130\" (*XXXXXXXX*)\n                        let print130 s = print_string (prefix130^\">>\"^s)\n\n                        exception ErrorCode of string\n\n                        exception TestException\n\n                        type result = Pass | Fail | ErrorCode of string\n\n                        let score = ref 0\n                        let max = ref 0\n                        let timeout = 300\n\n                        let runWTimeout (f,arg,out,time) = \n                          try if compare (f arg) out = 0 then Pass else Fail\n                          with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\n                        let testTest () =\n                          let testGood x = 1 in\n                          let testBad x = 0 in \n                          let testException x = raise TestException in\n                          let rec testTimeout x = testTimeout x in\n                            runWTimeout(testGood,0,1,5) = Pass &&  \n                            runWTimeout(testBad,0,1,5) = Fail &&  \n                            runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n                            runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n                        let runTest ((f,arg,out),points,name) =\n                          let _   = max := !max + points in\n                          let outs = \n                            match runWTimeout(f,arg,out,timeout) with \n                                Pass -> (score := !score + points; \"[pass]\")\n                              | Fail -> \"[fail]\"\n                              | ErrorCode e -> \"[error: \"^e^\"]\"  in\n                            name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n                        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                        let explode s = \n                          let rec _exp i = \n                            if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n                            _exp 0\n\n                        let implode cs = \n                          String.concat \"\" (List.map (String.make 1) cs)\n\n                        let drop_paren s = \n                          implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\n                        let eq_real p (r1,r2) = \n                          (r1 -. r2) < p || (r2 -. r1) < p\n\n                        let mkTest f x y name = runTest ((f, x, y), 1, name)\n\n                        let badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\n                        let scoreMsg () = \n                          Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\n                        let sampleTests =\n                          [\n                            (fun () -> mkTest\n                                         assoc\n                                         (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                                         23\n                                         \"sample: assoc 1\"\n                            );\n                            (fun () -> mkTest \n                                         assoc\n                                         (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                                         (-1)\n                                         \"sample: assoc 2\"\n                            ); \n                            (fun () -> mkTest \n                                         removeDuplicates\n                                         [1;6;2;4;12;2;13;6;9]\n                                         [1;6;2;4;12;13;9]\n                                         \"sample: removeDuplicates 2\"\n                            );\n                            (fun () -> mkTest \n                                         removeDuplicates\n                                         [1;1;1]\n                                         [1]\n                                         \"sample: removeDuplicates 2\"\n                            );\n\n                            (fun () -> mkTest \n                                         wwhile \n                                         ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                                         512 \n                                         \"sample: wwhile 1\"\n                            ); \n                            (fun () -> mkTest \n                                         fixpoint\n                                         ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                                         739085\n                                         \"sample: fixpoint 1\"\n                            ); \n\n                            (fun () -> mkTest \n                                         emitGrayscale\n                                         (eval_fn sampleExpr, 150,\"sample\")\n                                         ()\n                                         \"sample: eval_fn 1: manual\"\n                            ); \n                            (fun () -> mkTest \n                                         emitGrayscale\n                                         (eval_fn sampleExpr2, 150,\"sample2\")\n                                         ()\n                                         \"sample: eval_fn 2: manual\"\n                            );\n\n                            (fun () -> mkTest \n                                         (fun () -> doRandomGray (g1 ()))\n                                         ()\n                                         ()\n                                         \"sample: gray 1 : manual\"\n                            );\n                            (fun () -> mkTest \n                                         (fun () -> doRandomGray (g2 ()))\n                                         ()\n                                         ()\n                                         \"sample: gray 2 : manual\"\n                            );\n                            (fun () -> mkTest \n                                         (fun () -> doRandomGray (g3 ()))\n                                         ()\n                                         ()\n                                         \"sample: gray 3 : manual\"\n                            );\n\n                            (fun () -> mkTest \n                                         (fun () -> doRandomColor (c1 ()))\n                                         ()\n                                         ()\n                                         \"sample: color 1 : manual\"\n                            );\n                            (fun () -> mkTest \n                                         (fun () -> doRandomColor (c2 ()))\n                                         ()\n                                         ()\n                                         \"sample: color 2 : manual\"\n                            );\n                            (fun () -> mkTest \n                                         (fun () -> doRandomColor (c3 ()))\n                                         ()\n                                         ()\n                                         \"sample: color 3 : manual\"\n                            )] \n\n                        let doTest f = \n                          try f () with ex -> \n                            Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n                              (Printexc.to_string ex)\n\n                        let _ =\n                          let report = List.map doTest sampleTests                in\n                          let _      = List.iter print130 (report@([scoreMsg()])) in\n                          let _      = print130 (\"Compiled\\n\")                    in\n                            (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> 2. *. (atan eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"type","out":"Characters 419-423:\n  | Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) \n                             ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6105},"type":"eval"},"cursor":5947,"time":1.445056176670174e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> 2. *. (atan eval(e1,x,y)) \n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> (atan eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan eval (e1, x, y)\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"type","out":"Characters 413-417:\n  | Arctan (e1)\t\t  -> (atan eval(e1,x,y)) \n                       ^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> (atan eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6099},"type":"eval"},"cursor":5967,"time":1.445056195412116e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> (atan eval(e1,x,y)) \n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) \n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6099},"type":"eval"},"cursor":5947,"time":1.445056231455859e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) \n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":5451,"stop":6110},"type":"eval"},"cursor":5978,"time":1.445056245821485e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,5) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | _ -> buildThresh(build1, build2, build3, build4)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let buildArctan(e1)\t\t   = Arctan(e1)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n","type":"","out":""},{"in":"let buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1, build2)\n| 6 -> buildStrange(build1, build2, build3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan (build1, build2)\n     | 6 -> buildStrange (build1, build2, build3));;\n","type":"type","out":"Characters 524-540:\n  | 5 -> buildArctan(build1, build2)\n                    ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}],"event":{"phrases":["","let buildArctan(e1)\t\t   = Arctan(e1)","let buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1, build2)\n| 6 -> buildStrange(build1, build2, build3)"],"region":{"start":5424,"stop":7943},"type":"eval"},"cursor":7943,"time":1.445056365123958e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1, build2)\n        | 6 -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| 6 -> buildStrange(build1, build2, build3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | 6 -> buildStrange (build1, build2, build3));;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| 6 -> buildStrange(build1, build2, build3)"],"region":{"start":7008,"stop":7935},"type":"eval"},"cursor":7890,"time":1.445056375445073e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | 6 -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| _ -> buildStrange(build1, build2, build3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| _ -> buildStrange(build1, build2, build3)"],"region":{"start":7008,"stop":7935},"type":"eval"},"cursor":7895,"time":1.445056383951758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | _ -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| _ -> buildStrange(build1, build2, build3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n","type":"","out":""},{"in":"let g1 () = (9, 5, 123)","min":"\nlet g1 () = (9, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (10, 57, 28)","min":"\nlet g2 () = (10, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (7, 100, 999)","min":"\nlet g3 () = (7, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (4, 55, 13)","min":"\nlet c1 () = (4, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (5, 96, 194)","min":"\nlet c2 () = (5, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (6, 123, 498)","min":"\nlet c3 () = (6, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"( (\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^\n                       (\"(\" ^ ((exprToString e3) ^ (\")^2 + \" ^ \") / 3\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"( (\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^\n                       (\"(\" ^ ((exprToString e3) ^ (\")^2 + \" ^ \") / 3\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| _ -> buildStrange(build1, build2, build3)","let g1 () = (9, 5, 123)","let g2 () = (10, 57, 28)","let g3 () = (7, 100, 999)","let c1 () = (4, 55, 13)","let c2 () = (5, 96, 194)","let c3 () = (6, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7359,"stop":17427},"type":"eval"},"cursor":7895,"time":1.445056386232729e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | _ -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":8157,"time":1.445056415509528e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | _ -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (9, 5, 123)\nlet g2 () = (10, 57, 28)\nlet g3 () = (7, 100, 999) \n\nlet c1 () = (4, 55, 13)\nlet c2 () = (5, 96, 194)\nlet c3 () = (6, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":8293,"time":1.445056427237655e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"( (\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2 + \" ^\n                                 \") / 3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | _ -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (3, 5, 123)\nlet g2 () = (4, 57, 28)\nlet g3 () = (5, 100, 999) \n\nlet c1 () = (6, 55, 13)\nlet c2 () = (7, 96, 194)\nlet c3 () = (8, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n| Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n| Strange (e1,e2,e3)      -> \"((\" ^ exprToString e1 ^ \")^2 + \" ^ \n\"(\" ^ exprToString e2 ^ \")^2 + \" ^\n\"(\" ^ exprToString e3 ^ \")^2)/3\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^ (\"(\" ^ ((exprToString e3) ^ \")^2)/3\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^ (\"(\" ^ ((exprToString e3) ^ \")^2)/3\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildArctan(e1)\t\t   = Arctan(e1)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n","type":"","out":""},{"in":"let buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n| Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n| Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n| Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n\"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n| Strange (e1,e2,e3)      -> \"((\" ^ exprToString e1 ^ \")^2 + \" ^ \n\"(\" ^ exprToString e2 ^ \")^2 + \" ^\n\"(\" ^ exprToString e3 ^ \")^2)/3\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildArctan(e1)\t\t   = Arctan(e1)","let buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3."],"region":{"start":3877,"stop":6185},"type":"eval"},"cursor":6185,"time":1.445056487510385e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"((\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2)/3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | _ -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (2, 5, 123)\nlet g2 () = (3, 57, 28)\nlet g3 () = (4, 100, 999) \n\nlet c1 () = (5, 55, 13)\nlet c2 () = (6, 96, 194)\nlet c3 () = (7, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| _ -> buildStrange(build1, build2, build3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n","type":"","out":""},{"in":"let g1 () = (2, 5, 123)","min":"\nlet g1 () = (2, 5, 123);;\n","type":"","out":""},{"in":"let g2 () = (3, 57, 28)","min":"\nlet g2 () = (3, 57, 28);;\n","type":"","out":""},{"in":"let g3 () = (4, 100, 999)","min":"\nlet g3 () = (4, 100, 999);;\n","type":"","out":""},{"in":"let c1 () = (5, 55, 13)","min":"\nlet c1 () = (5, 55, 13);;\n","type":"","out":""},{"in":"let c2 () = (6, 96, 194)","min":"\nlet c2 () = (6, 96, 194);;\n","type":"","out":""},{"in":"let c3 () = (7, 123, 498)","min":"\nlet c3 () = (7, 123, 498);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^ (\"(\" ^ ((exprToString e3) ^ \")^2)/3\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> ((atan (eval (e1, x, y))) *. 2.) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | _ -> buildStrange (build1, build2, build3));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Arctan e1 -> \"2*arctan(\" ^ ((exprToString e1) ^ \")/pi\")\n  | Strange (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\")^2 + \" ^\n              (\"(\" ^\n                 ((exprToString e2) ^\n                    (\")^2 + \" ^ (\"(\" ^ ((exprToString e3) ^ \")^2)/3\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine (e1)               -> sin (pi *. eval(e1,x,y))\n| Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n| Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n| Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\neval(e2,x,y) *. eval(e2,x,y) +.\neval(e3,x,y) *. eval(e3,x,y) ) /. 3.","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let rec build (rand, depth) = \nif depth = 0 then\nlet result = rand(0,2) in\nmatch result with \n| 0 -> buildX()\n| _ -> buildY() \nelse\nlet result = rand(0,7) in\nlet build1 = build(rand, depth - 1) in\nlet build2 = build(rand, depth - 1) in\nlet build3 = build(rand, depth - 1) in\nlet build4 = build(rand, depth - 1) in\nmatch result with \n| 0 -> buildSine(build1)\n| 1 -> buildCosine(build1)\n| 2 -> buildAverage(build1, build2)\n| 3 -> buildTimes(build1, build2)\n| 4 -> buildThresh(build1, build2, build3, build4)\n| 5 -> buildArctan(build1)\n| _ -> buildStrange(build1, build2, build3)","let g1 () = (2, 5, 123)","let g2 () = (3, 57, 28)","let g3 () = (4, 100, 999)","let c1 () = (5, 55, 13)","let c2 () = (6, 96, 194)","let c3 () = (7, 123, 498)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":5610,"stop":17415},"type":"eval"},"cursor":6185,"time":1.445056492733465e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) = match l with\n  | [] -> d\n  | (name, number)::tail -> \n      if name = k \n      then number \n      else assoc (d, k, tail)\n;;\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      | [] -> seen\n      | h::rest' -> \n          let seen' = \n            if List.mem h seen \n            then seen \n            else h :: seen\n          in\n            helper (seen',rest')\n  in\n    List.rev (helper ([],l))\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) =\n  let (b', c') = f b in\n    if c'\n    then wwhile (f, b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = \n  let helper a = \n    let result = f a in\n      ( result, result != a )\n  in\n    wwhile (helper,b)\n;;\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Arctan   of expr\n    | Strange  of expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    | VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine (rest)             -> \"sin(pi*\" ^ (exprToString rest) ^ \")\"\n    | Cosine (rest)           -> \"cos(pi*\" ^ (exprToString rest) ^ \")\"\n    | Average (e1, e2)        -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2)\"\n    | Times  (e1, e2)         -> exprToString e1 ^ \"*\" ^ exprToString e2\n    | Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \n                                 \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n    | Arctan (e1)\t\t  -> \"2*arctan(\" ^ exprToString e1 ^ \")/pi\"\n    | Strange (e1,e2,e3)      -> \"((\" ^ exprToString e1 ^ \")^2 + \" ^ \n                                 \"(\" ^ exprToString e2 ^ \")^2 + \" ^\n                                 \"(\" ^ exprToString e3 ^ \")^2)/3\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\n\nlet _ = exprToString sampleExpr1 \n\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildArctan(e1)\t\t   = Arctan(e1)\nlet buildStrange(e1,e2,e3)\t   = Strange(e1,e2,e3)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = match e with \n  | VarX -> x\n  | VarY -> y\n  | Sine (e1)               -> sin (pi *. eval(e1,x,y))\n  | Cosine (e1)             -> cos (pi *. eval(e1,x,y))\n  | Average (e1, e2)        -> ( eval(e1,x,y) +. eval(e2,x,y) ) /. 2.\n  | Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n  | Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \n      then eval(e3,x,y)\n      else eval(e4,x,y)\n  | Arctan (e1)\t\t  -> atan (eval(e1,x,y)) *. 2. /. pi\n  | Strange (e1, e2, e3)    -> ( eval(e1,x,y) *. eval(e1,x,y) +.\n                                 eval(e2,x,y) *. eval(e2,x,y) +.\n                                 eval(e3,x,y) *. eval(e3,x,y) ) /. 3.\n;;\n\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if depth = 0 then\n    let result = rand(0,2) in\n      match result with \n        | 0 -> buildX()\n        | _ -> buildY() \n  else\n    let result = rand(0,7) in\n    let build1 = build(rand, depth - 1) in\n    let build2 = build(rand, depth - 1) in\n    let build3 = build(rand, depth - 1) in\n    let build4 = build(rand, depth - 1) in\n      match result with \n        | 0 -> buildSine(build1)\n        | 1 -> buildCosine(build1)\n        | 2 -> buildAverage(build1, build2)\n        | 3 -> buildTimes(build1, build2)\n        | 4 -> buildThresh(build1, build2, build3, build4)\n        | 5 -> buildArctan(build1)\n        | _ -> buildStrange(build1, build2, build3)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (2, 5, 123)\nlet g2 () = (3, 57, 28)\nlet g3 () = (4, 100, 999) \n\nlet c1 () = (5, 55, 13)\nlet c2 () = (6, 96, 194)\nlet c3 () = (7, 123, 498)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
