{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"],"region":{"start":0,"stop":1127},"type":"eval"},"cursor":1130,"time":1.444875682044153e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc([1,1],\"a\",[([1,2],\"cc\"),([1,1,1],\"a\")])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(([(1, 2)], \"cc\"), ([(1, 1, 1)], \"a\"))]);;\n","type":"type","out":"Characters 25-37:\n  let _ = assoc([1,1],\"a\",[([1,2],\"cc\"),([1,1,1],\"a\")]);;\n                           ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc([1,1],\"a\",[([1,2],\"cc\"),([1,1,1],\"a\")])"],"region":{"start":0,"stop":1181},"type":"eval"},"cursor":1181,"time":1.444878203678616e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[([1,2],\"cc\"),([1,1,1],\"a\")])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[([1,2],\"c\"),([1,1,1],\"a\")])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(([(1, 2)], \"c\"), ([(1, 1, 1)], \"a\"))]);;\n","type":"type","out":"Characters 25-36:\n  let _ = assoc([1,1],\"a\",[([1,2],\"c\"),([1,1,1],\"a\")]);;\n                           ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[([1,2],\"c\"),([1,1,1],\"a\")])"],"region":{"start":1125,"stop":1180},"type":"eval"},"cursor":1162,"time":1.444878219171868e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[([1,2],\"c\"),([1,1,1],\"a\")])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]),(\"a\",[1,1,1])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [((\"ca\", [(1, 2)]), (\"a\", [(1, 1, 1)]))]);;\n","type":"type","out":"Characters 25-37:\n  let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]),(\"a\",[1,1,1])]);;\n                           ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]),(\"a\",[1,1,1])])"],"region":{"start":1125,"stop":1181},"type":"eval"},"cursor":1179,"time":1.444878329609408e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]),(\"a\",[1,1,1])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[1,1,1])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"a\", [(1, 1, 1)])]);;\n","type":"type","out":"Characters 44-49:\n  let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[1,1,1])]);;\n                                              ^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int\n"}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[1,1,1])])"],"region":{"start":1125,"stop":1181},"type":"eval"},"cursor":1166,"time":1.444878343478998e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[1,1,1])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"a\", [(2, 2)])]);;\n","type":"","out":""}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2])])"],"region":{"start":1125,"stop":1179},"type":"eval"},"cursor":1175,"time":1.444878360293844e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2,3])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"a\", [(2, 2, 3)])]);;\n","type":"type","out":"Characters 44-49:\n  let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2,3])]);;\n                                              ^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int\n"}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2,3])])"],"region":{"start":1125,"stop":1181},"type":"eval"},"cursor":1177,"time":1.444878366002634e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"a\",[2,2,3])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])"],"region":{"start":1125,"stop":1180},"type":"eval"},"cursor":1170,"time":1.444878379976103e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""},{"in":"let rec filter l,a=\nmatch l with\n|[]->[]\n|h::t->if a=h then\nfilter t\nelse h::filter t","min":"","type":"syntax","out":"Characters 16-17:\n  let rec filter l,a=\n                  ^\nError: Syntax error\n"}],"event":{"phrases":["","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","let rec filter l,a=\nmatch l with\n|[]->[]\n|h::t->if a=h then\nfilter t\nelse h::filter t"],"region":{"start":1125,"stop":1761},"type":"eval"},"cursor":1761,"time":1.444879487155546e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l,a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t\n        else h::filter t\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::filter(t,h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|h::t->if a=h then\nfilter t\nelse h::filter t","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t else h :: (filter t);;\n","type":"type","out":"Characters 60-68:\n  filter t\n  ^^^^^^^^\nError: This expression has type 'a -> 'b list\n       but an expression was expected of type 'b list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|h::t->if a=h then\nfilter t\nelse h::filter t"],"region":{"start":1180,"stop":1761},"type":"eval"},"cursor":1761,"time":1.444879493993355e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t\n        else h::filter t\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::filter(t,h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|h::t->if a=h then\nfilter t a\nelse h::filter t a","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n","type":"","out":""}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|h::t->if a=h then\nfilter t a\nelse h::filter t a"],"region":{"start":1180,"stop":1765},"type":"eval"},"cursor":1765,"time":1.444879503995835e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::filter(t,h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::filter(t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter (t h)) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"type","out":"Characters 134-135:\n  let rest' = h::filter(t h) in \n                        ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"scope","out":"Characters 8-24:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n          ^^^^^^^^^^^^^^^^\nError: Unbound value removeDuplicates\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::filter(t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2008},"type":"eval"},"cursor":2010,"time":1.444879516692804e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::filter(t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"],"region":{"start":1765,"stop":1960},"type":"eval"},"cursor":1906,"time":1.444879549906177e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1960,"stop":2009},"type":"eval"},"cursor":2011,"time":1.444879572011976e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')","min":"","type":"syntax","out":"Characters 164-166:\n  helper (seen',rest');;\n                      ^^\nError: Syntax error\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":1982},"type":"eval"},"cursor":1984,"time":1.444879605335212e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest') \n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')","min":"","type":"syntax","out":"Characters 164-166:\n  helper (seen',rest');;\n                      ^^\nError: Syntax error\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":1985},"type":"eval"},"cursor":1987,"time":1.444879615376771e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest') \n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper seen',rest'","min":"","type":"syntax","out":"Characters 162-164:\n  helper seen',rest';;\n                    ^^\nError: Syntax error\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper seen',rest'"],"region":{"start":1765,"stop":1929},"type":"eval"},"cursor":1929,"time":1.444879634629238e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper seen',rest'\n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helpr([] l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helpr []);;\n","type":"scope","out":"Characters 185-190:\n  removeDuplicates(helpr([] l));;\n                   ^^^^^\nError: Unbound value helpr\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helpr([] l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2017},"type":"eval"},"cursor":2019,"time":1.444879700790965e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest')\n  in\n    removeDuplicates(helpr([] l))\n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper([] l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper []);;\n","type":"type","out":"Characters 191-197:\n  removeDuplicates(helper([] l));;\n                         ^^^^^^\nError: The constructor [] expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper([] l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2018},"type":"eval"},"cursor":2020,"time":1.444879707894628e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest')\n  in\n    removeDuplicates(helper([] l))\n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2019},"type":"eval"},"cursor":2022,"time":1.444879718076217e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if a=h then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest')\n  in\n    removeDuplicates(helper([], l))\n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|h::t->if h=a then\nfilter t a\nelse h::filter t a","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> rest\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> rest\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> rest\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|h::t->if h=a then\nfilter t a\nelse h::filter t a","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> rest\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2019},"type":"eval"},"cursor":2021,"time":1.444879780251447e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if h=a then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> rest\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest')\n  in\n    removeDuplicates(helper([], l))\n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> []\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper(_, l))","min":"","type":"syntax","out":"Characters 191-192:\n  removeDuplicates(helper(_, l));;\n                          ^\nError: Syntax error: operator expected.\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> rest\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> []\n| h::t -> \nlet seen' = h in\nlet rest' = h::(filter t h) in \nhelper (seen',rest')\nin\nremoveDuplicates(helper(_, l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2017},"type":"eval"},"cursor":2019,"time":1.444879879652093e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if h=a then\n          filter t a\n        else h::filter t a\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> []\n      | h::t -> \n          let seen' = h in\n          let rest' = h::(filter t h) in \n            helper (seen',rest')\n  in\n    removeDuplicates(helper(_, l))\n;;\n\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = seen@h in\nlet rest' = filter(t,h) in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen @ h in\n        let rest' = filter (t, h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"type","out":"Characters 136-141:\n  let rest' = filter(t,h) in \n                    ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> rest\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = seen@h in\nlet rest' = filter(t,h) in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2013},"type":"eval"},"cursor":2015,"time":1.444880200698601e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if h=a then\n          filter t a\n        else h::filter t a\n\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = seen@h in\n          let rest' = filter(t,h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = seen@h in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen @ h in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen @ h in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"type","out":"Characters 26-27:\n  let _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = seen@h in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1765,"stop":2012},"type":"eval"},"cursor":2014,"time":1.444880238626313e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |h::t->if h=a then\n          filter t a\n        else h::filter t a\n\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = seen@h in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter (tl, a)\nelse h::filter(t, a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else h :: (filter (t, a));;\n","type":"type","out":"Characters 70-77:\n  filter (tl, a)\n         ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter (tl, a)\nelse h::filter(t, a)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2024},"type":"eval"},"cursor":2026,"time":1.444881410424825e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a)\n        else h::filter(t, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter(tl, a)\nelse h::filter(t, a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else h :: (filter (t, a));;\n","type":"type","out":"Characters 69-76:\n  filter(tl, a)\n        ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter(tl, a)\nelse h::filter(t, a)"],"region":{"start":1180,"stop":1773},"type":"eval"},"cursor":1777,"time":1.444881424426582e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter(tl, a)\n        else h::filter(t, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter(tl, a)\nelse h::filter(tl, a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else h :: (filter (tl, a));;\n","type":"type","out":"Characters 69-76:\n  filter(tl, a)\n        ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter(tl, a)\nelse h::filter(tl, a)"],"region":{"start":1180,"stop":1774},"type":"eval"},"cursor":1777,"time":1.444881492075554e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter(tl, a)\n        else h::filter(tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter(tl, a)\nelse hd::filter(tl, a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else hd :: (filter (tl, a));;\n","type":"type","out":"Characters 69-76:\n  filter(tl, a)\n        ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter(tl, a)\nelse hd::filter(tl, a)"],"region":{"start":1180,"stop":1775},"type":"eval"},"cursor":1778,"time":1.444881505410397e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter(tl, a)\n        else hd::filter(tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl, a \nelse hd::filter(tl, a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then ((filter tl), a) else hd :: (filter (tl, a));;\n","type":"type","out":"Characters 63-75:\n  filter tl, a \n  ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl, a \nelse hd::filter(tl, a)"],"region":{"start":1180,"stop":1775},"type":"eval"},"cursor":1778,"time":1.444881634350589e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl, a \n        else hd::filter(tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::filter(tl, a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter (tl, a));;\n","type":"type","out":"Characters 91-98:\n  else hd::filter(tl, a);;\n                 ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::filter(tl, a)"],"region":{"start":1180,"stop":1774},"type":"eval"},"cursor":1778,"time":1.44488164537906e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::filter(tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::(filter tl a)","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter l a=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::(filter tl a)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2024},"type":"eval"},"cursor":2026,"time":1.444881661848466e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b',c')=(f b)\nin if c'= False then wwhile(f b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = False then wwhile (f b') else b';;\n","type":"scope","out":"Characters 52-57:\n  in if c'= False then wwhile(f b')\n            ^^^^^\nError: Unbound constructor False\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"scope","out":"Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b',c')=(f b)\nin if c'= False then wwhile(f b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2630},"type":"eval"},"cursor":2632,"time":1.444887437962209e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=(f b)\n  in if c'= False then wwhile(f b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b',c')=(f b)\nin if c'= false then wwhile(f b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then wwhile (f b') else b';;\n","type":"type","out":"Characters 69-75:\n  in if c'= false then wwhile(f b')\n                             ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"scope","out":"Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b',c')=(f b)\nin if c'= false then wwhile(f b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2630},"type":"eval"},"cursor":2633,"time":1.444887454305746e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=(f b)\n  in if c'= false then wwhile(f b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b',c')=(f b)\nin if c'= false then wwhile f b' \nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then wwhile f b' else b';;\n","type":"type","out":"Characters 70-71:\n  in if c'= false then wwhile f b' \n                              ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"scope","out":"Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b',c')=(f b)\nin if c'= false then wwhile f b' \nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2630},"type":"eval"},"cursor":2634,"time":1.44488747447287e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=(f b)\n  in if c'= false then wwhile f b' \n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet b' c'=(f b)\nin if c'= false then wwhile f b' \nelse b'","min":"\nlet rec wwhile (f,b) =\n  let b' c' = f b in if c' = false then wwhile f b' else b';;\n","type":"scope","out":"Characters 46-48:\n  in if c'= false then wwhile f b' \n        ^^\nError: Unbound value c'\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"scope","out":"Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet b' c'=(f b)\nin if c'= false then wwhile f b' \nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2628},"type":"eval"},"cursor":2630,"time":1.444887582650332e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let b' c'=(f b)\n  in if c'= false then wwhile f b' \n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b' ,c')=(f b)\nin if c'= true then (wwhile f b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile f b' else b';;\n","type":"type","out":"Characters 71-72:\n  in if c'= true then (wwhile f b')\n                              ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"scope","out":"Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b' ,c')=(f b)\nin if c'= true then (wwhile f b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2631},"type":"eval"},"cursor":2634,"time":1.444887685196058e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)\n  in if c'= true then (wwhile f b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b' ,c')=(f b)\nin if c'= true then wwhile (f b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f b') else b';;\n","type":"type","out":"Characters 70-76:\n  in if c'= true then wwhile (f b')\n                             ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"scope","out":"Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b' ,c')=(f b)\nin if c'= true then wwhile (f b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2631},"type":"eval"},"cursor":2634,"time":1.444887700606099e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)\n  in if c'= true then wwhile (f b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2631},"type":"eval"},"cursor":2634,"time":1.444887734017318e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then wwhile f b'\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile f b' else b';;\n","type":"type","out":"Characters 69-70:\n  if c'= true then wwhile f b'\n                          ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then wwhile f b'\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2628},"type":"eval"},"cursor":2632,"time":1.44488777218851e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile f b'\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then (wwhile f b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile f b' else b';;\n","type":"type","out":"Characters 70-71:\n  if c'= true then (wwhile f b')\n                           ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then (wwhile f b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2024,"stop":2630},"type":"eval"},"cursor":2634,"time":1.444887784564365e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter l a=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then (wwhile f b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter (l, a)=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::(filter tl a)","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n","type":"type","out":"Characters 66-72:\n  filter tl a \n  ^^^^^^\nError: This function has type 'a list * 'a -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter (l, a)=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::(filter tl a)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2027},"type":"eval"},"cursor":2029,"time":1.444887827445361e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::(filter tl a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter (l, a)=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::filter (tl, a)","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter (tl, a));;\n","type":"type","out":"Characters 66-72:\n  filter tl a \n  ^^^^^^\nError: This function has type 'a list * 'a -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter tl a else hd :: (filter tl a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter (l, a)=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter tl a \nelse hd::filter (tl, a)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter t h in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2028},"type":"eval"},"cursor":2030,"time":1.444887844205306e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter tl a \n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter t h in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter (l, a)=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter (tl, a )\nelse hd::filter (tl, a)","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else hd :: (filter (tl, a));;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter (t, h) in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else hd :: (filter (tl, a));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter (t, h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else hd :: (filter (tl, a));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter (t, h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter (l, a)=\nmatch l with\n|[]->[]\n|hd::tl->if hd=a then\nfilter (tl, a )\nelse hd::filter (tl, a)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = filter (t, h) in \nhelper (seen',rest')\nin\nList.rev(helper([], l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2034},"type":"eval"},"cursor":2036,"time":1.444887874979363e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then wwhile (f, b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let helper f b=\nif f b=b then true\nelse false","min":"\nlet helper f b = if (f b) = b then true else false;;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile (helper (f,b),b)","min":"\nlet helper f b = if (f b) = b then true else false;;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n","type":"type","out":"Characters 36-41:\n  let fixpoint (f,b) = wwhile (helper (f,b),b);;\n                                      ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"scope","out":"Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 1);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 3);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 48);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 107);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b' ,c')=(f b)in\nif c'= true then wwhile (f, b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let helper f b=\nif f b=b then true\nelse false","let fixpoint (f,b) = wwhile (helper (f,b),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2034,"stop":3401},"type":"eval"},"cursor":3405,"time":1.444888759159321e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if f b=b then true\n  else false\n;;\n\nlet fixpoint (f,b) = wwhile (helper (f,b),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = wwhile ( (helper f b),b)","min":"\nlet helper f b = if (f b) = b then true else false;;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f b), b);;\n","type":"type","out":"Characters 30-42:\n  let fixpoint (f,b) = wwhile ( (helper f b),b);;\n                                ^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"scope","out":"Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 1);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 3);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 48);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 107);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"}],"event":{"phrases":["","let fixpoint (f,b) = wwhile ( (helper f b),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3028,"stop":3402},"type":"eval"},"cursor":3406,"time":1.444888786872492e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if f b=b then true\n  else false\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f b),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let helper f b=\nif f b=b then (true,b)\nelse (false,f b)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ( (helper f b),b)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f b), b);;\n","type":"type","out":"Characters 30-42:\n  let fixpoint (f,b) = wwhile ( (helper f b),b);;\n                                ^^^^^^^^^^^^\nError: This expression has type bool * 'a\n       but an expression was expected of type 'b -> 'b * bool\n"},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"scope","out":"Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 1);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 3);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 48);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 107);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"scope","out":"Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n"}],"event":{"phrases":["","let helper f b=\nif f b=b then (true,b)\nelse (false,f b)","let fixpoint (f,b) = wwhile ( (helper f b),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2641,"stop":3412},"type":"eval"},"cursor":3415,"time":1.444888832783681e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if f b=b then (true,b)\n  else (false,f b)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f b),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = wwhile ( (helper f),b)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 3);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 48);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 107);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let fixpoint (f,b) = wwhile ( (helper f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3038,"stop":3410},"type":"eval"},"cursor":3414,"time":1.444888888080417e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if f b=b then (true,b)\n  else (false,f b)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let helper f b=\nif (f b)=b then (true,b)\nelse (false,f b)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ( (helper f),b)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let helper f b=\nif (f b)=b then (true,b)\nelse (false,f b)","let fixpoint (f,b) = wwhile ( (helper f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)"],"region":{"start":2641,"stop":3274},"type":"eval"},"cursor":3277,"time":1.444889221618271e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (true,b)\n  else (false,f b)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 3);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 48);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 107);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3088,"stop":3412},"type":"eval"},"cursor":3415,"time":1.444889228563451e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (true,b)\n  else (false,f b)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let helper f b=\nif (f b)=b then (true,b)\nelse (false,(f b))","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ( (helper f),b)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 3);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 48);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 107);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let helper f b=\nif (f b)=b then (true,b)\nelse (false,(f b))","let fixpoint (f,b) = wwhile ( (helper f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2641,"stop":3414},"type":"eval"},"cursor":3417,"time":1.44488926997886e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (true,b)\n  else (false,(f b))\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let helper f b=\nlet res=f b in\nif res=b then (b,true)\nelse ((f b),false)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ( (helper f),b)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b =\n  let res = f b in if res = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let helper f b=\nlet res=f b in\nif res=b then (b,true)\nelse ((f b),false)","let fixpoint (f,b) = wwhile ( (helper f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2641,"stop":3427},"type":"eval"},"cursor":3431,"time":1.444890078106876e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  let res=f b in\n    if res=b then (b,true)\n    else ((f b),false)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":3431,"time":1.444890113032727e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  let res=f b in\n    if res=b then (b,true)\n    else ((f b),false)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let helper f b=\nif (f b)=b then (b,true)\nelse ((f b),false)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ( (helper f),b)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let helper f b=\nif (f b)=b then (b,true)\nelse ((f b),false)","let fixpoint (f,b) = wwhile ( (helper f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2641,"stop":3414},"type":"eval"},"cursor":3417,"time":1.44489012767884e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (b,true)\n  else ((f b),false)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":3417,"time":1.44489013045973e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (b,true)\n  else ((f b),false)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""}],"event":{"phrases":["","let _ = fixpoint (collatz, 1)"],"region":{"start":3243,"stop":3276},"type":"eval"},"cursor":3279,"time":1.444890249158757e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (b,true)\n  else ((f b),false)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":3279,"time":1.444890283861753e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec filter (l, a)=\n  match l with\n    |[]->[]\n    |hd::tl->if hd=a then\n          filter (tl, a )\n        else hd::filter (tl, a)\n;;\n\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n      |[] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = filter (t, h) in \n            helper (seen',rest')\n  in\n    List.rev(helper([], l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b' ,c')=(f b)in\n    if c'= true then wwhile (f, b')\n    else b'\n;;\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet helper f b=\n  if (f b)=b then (b,true)\n  else ((f b),false)\n;;\n\nlet fixpoint (f,b) = wwhile ( (helper f),b)\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":0,"stop":2556},"type":"eval"},"cursor":2558,"time":1.444890896527374e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = failwith \"to be written\" in\n          let rest' = failwith \"to be written\" in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then hd::(filter tl h)\nelse filter tl h","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else hd :: (filter (tl, a));;\n\nlet filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then hd :: (filter tl h) else filter tl h;;\n","type":"type","out":"Characters 65-71:\n  |hd::tl -> if hd=h then hd::(filter tl h)\n                               ^^^^^^\nError: This function has type 'a list * 'a -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter (l,a) =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = a then filter (tl, a) else hd :: (filter (tl, a));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"type","out":"Characters 131-137:\n  let rest' = (filter t h) in \n               ^^^^^^\nError: This function has type 'a list * 'a -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then hd::(filter tl h)\nelse filter tl h","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"],"region":{"start":1180,"stop":1972},"type":"eval"},"cursor":1972,"time":1.444891139409525e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then hd::(filter tl h)\n        else filter tl h\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then hd::(filter tl h)\nelse filter tl h","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then hd :: (filter tl h) else filter tl h;;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then hd :: (filter tl h) else filter tl h;;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then hd :: (filter tl h) else filter tl h;;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then hd::(filter tl h)\nelse filter tl h","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2025},"type":"eval"},"cursor":2027,"time":1.44489116776498e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then hd::(filter tl h)\n        else filter tl h\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse h::(filter tl h)","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else h :: (filter tl h);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else h :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else h :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse h::(filter tl h)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2026},"type":"eval"},"cursor":2028,"time":1.444891214974394e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else h::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"],"region":{"start":1180,"stop":2027},"type":"eval"},"cursor":2029,"time":1.444891275658977e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""}],"event":{"phrases":["","let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"],"region":{"start":2027,"stop":2632},"type":"eval"},"cursor":2635,"time":1.444891300856078e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile (f1 f,b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then false else true in wwhile ((f1 f), b);;\n","type":"type","out":"Characters 76-80:\n  let fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile (f1 f,b);;\n                                                                              ^^^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile (f1 f,b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2632,"stop":3450},"type":"eval"},"cursor":3453,"time":1.444891617015453e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile (f1 f,b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then false else true in wwhile ((f1 f), b);;\n","type":"type","out":"Characters 76-82:\n  let fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile ((f1 f),b);;\n                                                                              ^^^^^^\nError: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2632,"stop":3452},"type":"eval"},"cursor":3455,"time":1.444891638481269e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = let f1 f2 x= if f2 x=x then false else true in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then false else true in wwhile ((f1 f),b)","min":"","type":"syntax","out":"Characters 27-28:\n  let fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then false else true in wwhile ((f1 f),b);;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet helper f b = if (f b) = b then (b, true) else ((f b), false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then false else true in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":2632,"stop":3455},"type":"eval"},"cursor":3458,"time":1.444891662117554e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then false else true in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)","min":"","type":"syntax","out":"Characters 27-28:\n  let fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b);;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","let fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)"],"region":{"start":2632,"stop":3075},"type":"eval"},"cursor":3075,"time":1.444891833348479e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1(f2 x)= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)"],"region":{"start":2632,"stop":3074},"type":"eval"},"cursor":3074,"time":1.444891862378372e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 1);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 3);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 48);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 107);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"type","out":"Characters 18-25:\n  let _ = fixpoint (collatz, 9001);;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)"],"region":{"start":3074,"stop":3399},"type":"eval"},"cursor":3402,"time":1.444891871295188e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, f2 x) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, (f2 x)) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"type","out":"Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"}],"event":{"phrases":["","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, (f2 x)) in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"],"region":{"start":2632,"stop":3147},"type":"eval"},"cursor":3150,"time":1.444891941983059e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (false,x) else (true, (f2 x)) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else ((f2 x),true) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""}],"event":{"phrases":["","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else ((f2 x),true) in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)"],"region":{"start":2632,"stop":3364},"type":"eval"},"cursor":3367,"time":1.444892003206437e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \n\nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else ((f2 x),true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""},{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)"],"region":{"start":0,"stop":3361},"type":"eval"},"cursor":3364,"time":1.444893760682633e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 3","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 3;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 3"],"region":{"start":3226,"stop":3246},"type":"eval"},"cursor":3248,"time":1.444893830220706e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 3;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 10","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 10;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 10"],"region":{"start":3226,"stop":3247},"type":"eval"},"cursor":3249,"time":1.444893845616067e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 10;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 5","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 5;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 5"],"region":{"start":3226,"stop":3246},"type":"eval"},"cursor":3248,"time":1.444893859939204e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 5;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 16","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 16;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 16"],"region":{"start":3226,"stop":3247},"type":"eval"},"cursor":3249,"time":1.444893870198176e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 16;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 8","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 8;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 8"],"region":{"start":3226,"stop":3246},"type":"eval"},"cursor":3248,"time":1.444893902094412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 8;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 4","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 4;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 4"],"region":{"start":3226,"stop":3246},"type":"eval"},"cursor":3248,"time":1.444893909125793e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 4;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =collatz 2","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 2;;\n","type":"","out":""}],"event":{"phrases":["","let _ =collatz 2"],"region":{"start":3226,"stop":3246},"type":"eval"},"cursor":3248,"time":1.444893915089675e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ =collatz 2","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 2;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString x)^\"*\"^(exprToString e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> \"(x<y?x:\" ^ ((exprToString d) ^ \")\")\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ ((exprToString e2) ^ \")/2\"))\n  | Times (e1,e2) -> (exprToString x) ^ (\"*\" ^ (exprToString e2));;\n","type":"scope","out":"Characters 303-304:\n  |Times(e1,e2)   ->(exprToString x)^\"*\"^(exprToString e2);;\n                                  ^\nError: Unbound value x\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"scope","out":"Characters 8-20:\n  let _ = exprToString sampleExpr1;;\n          ^^^^^^^^^^^^\nError: Unbound value exprToString\n"}],"event":{"phrases":["","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ =collatz 2","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString x)^\"*\"^(exprToString e2)","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1"],"region":{"start":3143,"stop":4438},"type":"eval"},"cursor":4439,"time":1.444896599290349e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString x)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> \"(x<y?x:\" ^ ((exprToString d) ^ \")\")\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ ((exprToString e2) ^ \")/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> \"(x<y?x:\" ^ ((exprToString d) ^ \")\")\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ ((exprToString e2) ^ \")/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1"],"region":{"start":3887,"stop":4439},"type":"eval"},"cursor":4440,"time":1.44489663206723e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> \"(x<y?x:\" ^ ((exprToString d) ^ \")\")\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> \"(x<y?x:\" ^ ((exprToString d) ^ \")\")\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1"],"region":{"start":3887,"stop":4443},"type":"eval"},"cursor":4443,"time":1.444896676129951e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(x<y?x:\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString y^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n","type":"scope","out":"Characters 93-94:\n  |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString y^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n                                                        ^\nError: Unbound value y\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> \"(x<y?x:\" ^ ((exprToString d) ^ \")\")\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString y^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1"],"region":{"start":3887,"stop":4494},"type":"eval"},"cursor":4495,"time":1.444897328907368e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString y^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1"],"region":{"start":3887,"stop":4494},"type":"eval"},"cursor":4495,"time":1.44489733988543e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""},{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ =collatz 2","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 2;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) =","min":"","type":"syntax","out":"Characters 22-24:\n  let rec eval (e,x,y) =;;\n                        ^^\nError: Syntax error\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"scope","out":"Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ =collatz 2","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t->\"x\"\n|VarY\t\t->\"y\"\n|Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) =","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"],"region":{"start":0,"stop":5409},"type":"eval"},"cursor":5410,"time":1.445049713377821e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = ((eval (a, x, y)), (x2 = (eval (b, x, y)))) in\n      if x1 < x2 then eval a_less else eval b_less;;\n","type":"type","out":"Characters 138-149:\n  |Average(a,b)->(eval(a,x,y)+eval(b,x,y))/.2\n                  ^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5612},"type":"eval"},"cursor":5615,"time":1.445051294820677e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+eval(b,x,y))/.2\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(.eval(a,x,y)+.eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","min":"","type":"syntax","out":"Characters 138-139:\n  |Average(a,b)->(.eval(a,x,y)+.eval(b,x,y))/.2\n                  ^\nError: Syntax error: operator expected.\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(.eval(a,x,y)+.eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"],"region":{"start":5073,"stop":5578},"type":"eval"},"cursor":5580,"time":1.445051337821286e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(.eval(a,x,y)+.eval(b,x,y))/.2\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = ((eval (a, x, y)), (x2 = (eval (b, x, y)))) in\n      if x1 < x2 then eval a_less else eval b_less;;\n","type":"type","out":"Characters 165-166:\n  |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n                                             ^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5613},"type":"eval"},"cursor":5616,"time":1.445051678848873e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = ((eval (a, x, y)), (x2 = (eval (b, x, y)))) in\n      if x1 < x2 then eval a_less else eval b_less;;\n","type":"scope","out":"Characters 256-258:\n  |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less;;\n                                                 ^^\nError: Unbound value x2\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5617},"type":"eval"},"cursor":5619,"time":1.445051724898114e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y),x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less) else eval b_less\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y)","min":"","type":"syntax","out":"Characters 255-257:\n  |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y);;\n                                                ^^\nError: Syntax error\n"},{"in":"let x2=eval(b,x,y)  \nin  if(x1<x2) then eval(a_less) else eval b_less","min":"\nlet _ =\n  let x2 = eval (b, x, y) in if x1 < x2 then eval a_less else eval b_less;;\n","type":"scope","out":"Characters 7-11:\n  let x2=eval(b,x,y)  \n         ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y)","let x2=eval(b,x,y)  \nin  if(x1<x2) then eval(a_less) else eval b_less","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5622},"type":"eval"},"cursor":5624,"time":1.445051747382786e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) let x2=eval(b,x,y)  \nin  if(x1<x2) then eval(a_less) else eval b_less\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y)","min":"","type":"syntax","out":"Characters 255-257:\n  |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y);;\n                                                ^^\nError: Syntax error\n"},{"in":"let x2=eval(b,x,y)  \nin  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y","min":"\nlet _ =\n  let x2 = eval (b, x, y) in\n  if x1 < x2 then eval (a_less, x, y) else ((eval b_less), x, y);;\n","type":"scope","out":"Characters 7-11:\n  let x2=eval(b,x,y)  \n         ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y)","let x2=eval(b,x,y)  \nin  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5630},"type":"eval"},"cursor":5632,"time":1.445051766439752e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) let x2=eval(b,x,y)  \nin  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y)","min":"","type":"syntax","out":"Characters 255-257:\n  |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y);;\n                                                ^^\nError: Syntax error\n"},{"in":"let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y","min":"\nlet _ =\n  let x2 = eval (b, x, y) in\n  if x1 < x2 then eval (a_less, x, y) else ((eval b_less), x, y);;\n","type":"scope","out":"Characters 7-11:\n  let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y;;\n         ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y)","let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y"],"region":{"start":5073,"stop":5490},"type":"eval"},"cursor":5493,"time":1.445051790004085e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else ((eval b_less), x, y);;\n","type":"type","out":"Characters 320-335:\n  |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y;;\n                                                                                                                 ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5632},"type":"eval"},"cursor":5634,"time":1.445051836126995e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval b_less,x,y\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval a_less,x,y else eval b_less,x,y","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then ((eval a_less), x, y) else ((eval b_less), x, y);;\n","type":"type","out":"Characters 298-313:\n  |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval a_less,x,y else eval b_less,x,y;;\n                                                                                           ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n          ^^^^\nError: Unbound value eval\n"},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval a_less,x,y else eval b_less,x,y","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5631},"type":"eval"},"cursor":5633,"time":1.445051859574599e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval a_less,x,y else eval b_less,x,y\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5634},"type":"eval"},"cursor":5636,"time":1.445051877881361e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))*.(0.5)\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n","type":"type","out":"Characters 165-166:\n  |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n                                             ^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5630},"type":"eval"},"cursor":5632,"time":1.445051918702788e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/2.0\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n","type":"type","out":"Characters 137-163:\n  |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/2.0\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/2.0\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5631},"type":"eval"},"cursor":5633,"time":1.44505193218965e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/2.0\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr,0.5,0.2)"],"region":{"start":5073,"stop":5632},"type":"eval"},"cursor":5634,"time":1.445051945066989e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":5596,"stop":5633},"type":"eval"},"cursor":5635,"time":1.445051954966681e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)/.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0, (-0.5));;\n","type":"type","out":"Characters 39-40:\n  let _ = eval (Sine(Average(VarX,VarY)),0,-0.5);;\n                                         ^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)","let _ = eval (Sine(Average(VarX,VarY)),0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":5073,"stop":5631},"type":"eval"},"cursor":5633,"time":1.44505214544745e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ = eval (sampleExpr1,0.5,0.2)"],"region":{"start":5493,"stop":5633},"type":"eval"},"cursor":5635,"time":1.445052158254514e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"scope","out":"Characters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\n"},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval (sampleExpr,0.5,0.2)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"],"region":{"start":5596,"stop":6166},"type":"eval"},"cursor":6167,"time":1.445052300282543e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let _=eval(sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""}],"event":{"phrases":["","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let _=eval(sampleExpr,0.5,0.2)","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"],"region":{"start":5596,"stop":6160},"type":"eval"},"cursor":6160,"time":1.445052427740991e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let _=eval(sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n|3->buildCosin(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1))","min":"","type":"scope","out":"Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr\nError: Unbound constructor Cosine\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 158-210:\n  |2->buildSine(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr\n"}],"event":{"phrases":["","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let _=eval(sampleExpr,0.5,0.2)","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n|3->buildCosin(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1))"],"region":{"start":5685,"stop":6958},"type":"eval"},"cursor":6961,"time":1.445053861125849e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n      |3->buildCosin(sampleExpr,build(rand,depth-1),build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosin(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosin (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n","type":"scope","out":"Characters 184-194:\n  |3->buildCosin(build(rand,depth-1))\n      ^^^^^^^^^^\nError: Unbound value buildCosin\n"}],"event":{"phrases":["","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosin(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"],"region":{"start":6160,"stop":6956},"type":"eval"},"cursor":6961,"time":1.445054116136616e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(build(rand,depth-1))\n      |3->buildCosin(build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n","type":"type","out":"Characters 346-447:\n  |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1));;\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c * 'd * 'e\n       but an expression was expected of type expr * expr * expr * expr\n"}],"event":{"phrases":["","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"],"region":{"start":6160,"stop":6957},"type":"eval"},"cursor":6960,"time":1.445054125861564e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(build(rand,depth-1))\n      |3->buildCosine(build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"],"region":{"start":6160,"stop":6937},"type":"eval"},"cursor":6940,"time":1.445054166049127e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(build(rand,depth-1))\n      |3->buildCosine(build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _=build(rand,5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet _ = build (rand, 5);;\n","type":"scope","out":"Characters 12-16:\n  let _=build(rand,5);;\n              ^^^^\nError: Unbound value rand\n"}],"event":{"phrases":["","let _=build(rand,5)"],"region":{"start":6937,"stop":6961},"type":"eval"},"cursor":6961,"time":1.445054247902597e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(build(rand,depth-1))\n      |3->buildCosine(build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\nlet _=build(rand,5)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = \n  let g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g1 () = (5,91,13)","min":"\nlet g1 () = (5, 91, 13);;\n","type":"","out":""}],"event":{"phrases":["","let g1 () = (5,91,13)"],"region":{"start":6937,"stop":7165},"type":"eval"},"cursor":7165,"time":1.44505488041004e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(build(rand,depth-1))\n      |3->buildCosine(build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g2 () = (3,66,8)","min":"\nlet g2 () = (3, 66, 8);;\n","type":"","out":""},{"in":"let g3 () = (10,88,9)","min":"\nlet g3 () = (10, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (11,100,11)","min":"\nlet c2 () = (11, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let g2 () = (3,66,8)","let g3 () = (10,88,9)","let c1 () = (8,90,10)","let c2 () = (11,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7165,"stop":16465},"type":"eval"},"cursor":7283,"time":1.445055001226723e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d)->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t->\"x\"\n    |VarY\t\t->\"y\"\n    |Sine(x)\t->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)      ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2) -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)   ->(exprToString e1)^\"*\"^(exprToString e2)\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildX()\n      |1->buildY()\n      |2->buildSine(build(rand,depth-1))\n      |3->buildCosine(build(rand,depth-1))\n      |4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,8)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Cube     of expr * expr\n| Square   of expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr* expr\n  | Square of expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Cube(e1,e2)     ->\"(\"^(expoToString e1)^\")^3\"\n|Square(e)\t ->\"(\"^(expoToString e)^\")^2\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube (e1,e2) -> \"(\" ^ ((expoToString e1) ^ \")^3\")\n  | Square e -> \"(\" ^ ((expoToString e) ^ \")^2\");;\n","type":"scope","out":"Characters 415-427:\n  |Cube(e1,e2)     ->\"(\"^(expoToString e1)^\")^3\"\n                          ^^^^^^^^^^^^\nError: Unbound value expoToString\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr* expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Cube (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))));;\n","type":"type","out":"Characters 40-92:\n  let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))));;\n                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: The constructor Cube expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}],"event":{"phrases":["","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Cube     of expr * expr\n| Square   of expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Cube(e1,e2)     ->\"(\"^(expoToString e1)^\")^3\"\n|Square(e)\t ->\"(\"^(expoToString e)^\")^2\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))))"],"region":{"start":3417,"stop":4603},"type":"eval"},"cursor":4605,"time":1.445056085730869e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr * expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e1,e2)     ->\"(\"^(expoToString e1)^\")^3\"\n    |Square(e)\t ->\"(\"^(expoToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Cube     of expr\n| Square   of expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Cube(e)     ->\"(\"^(expoToString e)^\")^3\"\n|Square(e)\t ->\"(\"^(expoToString e)^\")^2\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube e -> \"(\" ^ ((expoToString e) ^ \")^3\")\n  | Square e -> \"(\" ^ ((expoToString e) ^ \")^2\");;\n","type":"scope","out":"Characters 411-423:\n  |Cube(e)     ->\"(\"^(expoToString e)^\")^3\"\n                      ^^^^^^^^^^^^\nError: Unbound value expoToString\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Cube (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))));;\n","type":"","out":""}],"event":{"phrases":["","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Cube     of expr\n| Square   of expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Cube(e)     ->\"(\"^(expoToString e)^\")^3\"\n|Square(e)\t ->\"(\"^(expoToString e)^\")^2\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))))"],"region":{"start":3417,"stop":4591},"type":"eval"},"cursor":4593,"time":1.445056105173758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(expoToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(expoToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube e -> \"(\" ^ ((exprToString e) ^ \")^3\")\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Cube (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))));;\n","type":"","out":""}],"event":{"phrases":["","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))))"],"region":{"start":3926,"stop":4591},"type":"eval"},"cursor":4593,"time":1.445056125411774e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube e -> \"(\" ^ ((exprToString e) ^ \")^3\")\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Cube (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""}],"event":{"phrases":["","let _ = exprToString sampleExpr1"],"region":{"start":4591,"stop":4627},"type":"eval"},"cursor":4628,"time":1.445056132258221e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Cube(Times(Sine(VarX),Cosine(Average(VarX,VarY))))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n","type":"","out":""},{"in":")","min":"","type":"syntax","out":"Characters 0-1:\n  );;\n  ^\nError: Syntax error\n"},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube e -> \"(\" ^ ((exprToString e) ^ \")^3\")\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildCube(e)\t\t   = Cube(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildCube e = Cube e;;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","min":"","type":"syntax","out":"Characters 382-383:\n  | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n                                                ^\nError: Syntax error\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1)","min":"","type":"type","out":"Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: This variant expression is expected to have type expr\n       The constructor Cube does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 11-24:\n  let _ =eval(sampleExpr1);;\n             ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}],"event":{"phrases":["","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))",")","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildCube(e)\t\t   = Cube(e)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1)"],"region":{"start":4491,"stop":5930},"type":"eval"},"cursor":5930,"time":1.445056414721624e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY))))));;\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n    |Square(a)->let tempp=eval(a,x,y) in temp*.temp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":")","min":"","type":"syntax","out":"Characters 0-1:\n  );;\n  ^\nError: Syntax error\n"},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube e -> \"(\" ^ ((exprToString e) ^ \")^3\")\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildCube(e)\t\t   = Cube(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildCube e = Cube e;;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","min":"","type":"syntax","out":"Characters 382-383:\n  | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n                                                ^\nError: Syntax error\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1)","min":"","type":"type","out":"Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: This variant expression is expected to have type expr\n       The constructor Cube does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 11-24:\n  let _ =eval(sampleExpr1);;\n             ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}],"event":{"phrases":["",")","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildCube(e)\t\t   = Cube(e)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1)"],"region":{"start":4599,"stop":5928},"type":"eval"},"cursor":5928,"time":1.445056479238915e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY))))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n    |Square(a)->let tempp=eval(a,x,y) in temp*.temp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n","type":"","out":""}],"event":{"phrases":["","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))"],"region":{"start":4491,"stop":4599},"type":"eval"},"cursor":4599,"time":1.445056497027317e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n    |Square(a)->let tempp=eval(a,x,y) in temp*.temp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Cube e -> \"(\" ^ ((exprToString e) ^ \")^3\")\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildCube(e)\t\t   = Cube(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildCube e = Cube e;;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","min":"","type":"syntax","out":"Characters 382-383:\n  | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n                                                ^\nError: Syntax error\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1)","min":"","type":"type","out":"Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: This variant expression is expected to have type expr\n       The constructor Cube does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 11-24:\n  let _ =eval(sampleExpr1);;\n             ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}],"event":{"phrases":["","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildCube(e)\t\t   = Cube(e)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1)"],"region":{"start":4599,"stop":5927},"type":"eval"},"cursor":5927,"time":1.445056505722501e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp.*temp\n    |Square(a)->let tempp=eval(a,x,y) in temp*.temp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in temp *. temp;;\n","type":"scope","out":"Characters 425-429:\n  |Square(a)->let tempp=eval(a,x,y) in temp*.temp;;\n                                       ^^^^\nError: Unbound value temp\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1)","min":"","type":"type","out":"Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: This variant expression is expected to have type expr\n       The constructor Cube does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 11-24:\n  let _ =eval(sampleExpr1);;\n             ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n|Square(a)->let tempp=eval(a,x,y) in temp*.temp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1)"],"region":{"start":5277,"stop":5927},"type":"eval"},"cursor":5927,"time":1.445056553032358e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n    |Square(a)->let tempp=eval(a,x,y) in temp*.temp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval sampleExpr1;;\n","type":"type","out":"Characters 11-24:\n  let _ =eval(sampleExpr1);;\n             ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}],"event":{"phrases":["","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n| Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1)"],"region":{"start":5277,"stop":5929},"type":"eval"},"cursor":5929,"time":1.445056564435152e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =eval(sampleExpr1,0.2,0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.2, 0.5);;\n","type":"","out":""}],"event":{"phrases":["","let _ =eval(sampleExpr1,0.2,0.5)"],"region":{"start":5902,"stop":5937},"type":"eval"},"cursor":5937,"time":1.445056588171663e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.2,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =eval(sampleExpr1,0.5,0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.5);;\n","type":"","out":""}],"event":{"phrases":["","let _ =eval(sampleExpr1,0.5,0.5)"],"region":{"start":5902,"stop":5937},"type":"eval"},"cursor":5937,"time":1.445056603958591e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.5,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let _ =eval(sampleExpr1,0.9,0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Cube a -> let temp = eval (a, x, y) in (temp *. temp) *. temp\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine (Cube VarX)), (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.9, 0.5);;\n","type":"","out":""}],"event":{"phrases":["","let _ =eval(sampleExpr1,0.9,0.5)"],"region":{"start":5902,"stop":5937},"type":"eval"},"cursor":5937,"time":1.445056613329272e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Cube     of expr\n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Cube(e)     ->\"(\"^(exprToString e)^\")^3\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Cube(VarX)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildCube(e)\t\t   = Cube(e)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    | Cube(a)->let temp=eval(a,x,y) in temp*.temp*.temp\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->build\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Mean3    of expr * expr * expr \n| Square   of expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n","type":"type","out":"Characters 52-56:\n  let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))));;\n                                                      ^^^^\nError: This variant expression is expected to have type expr\n       The constructor Mean does not belong to type expr\n"},{"in":"let _ = exprToString sampleExpr1","min":"","type":"type","out":"Error: This expression has type expr/3580\n       but an expression was expected of type expr/3959\nError: This variant expression is expected to have type expr\n       The constructor Cube does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 21-32:\n  let _ = exprToString sampleExpr1;;\n                       ^^^^^^^^^^^\nError: This expression has type expr/3580\n       but an expression was expected of type expr/3959\n"},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1,0.9,0.5)","min":"","type":"type","out":"Error: This expression has type expr/3580\n       but an expression was expected of type expr/3959\nError: This variant expression is expected to have type expr\n       The constructor Cube does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 12-23:\n  let _ =eval(sampleExpr1,0.9,0.5);;\n              ^^^^^^^^^^^\nError: This expression has type expr/3580\n       but an expression was expected of type expr/3959\n"}],"event":{"phrases":["","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Mean3    of expr * expr * expr \n| Square   of expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1,0.9,0.5)"],"region":{"start":3417,"stop":6038},"type":"eval"},"cursor":6038,"time":1.44505714542442e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildCube(build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1,0.9,0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.9, 0.5);;\n","type":"","out":""}],"event":{"phrases":["","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1,0.9,0.5)"],"region":{"start":4559,"stop":6039},"type":"eval"},"cursor":6039,"time":1.445057160568423e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildCube(build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let _=eval(sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,8) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildCube(build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","min":"","type":"type","out":"Error: This expression has type expr/3959\n       but an expression was expected of type expr/3580\nError: This expression has type expr/4189\n       but an expression was expected of type expr/4179\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 415-436:\n  |5->buildCube(build(rand,depth-1))\n               ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr/3959\n       but an expression was expected of type expr/3580\n"},{"in":"let g1 () = (5,91,13)","min":"\nlet g1 () = (5, 91, 13);;\n","type":"","out":""},{"in":"let g2 () = (3,66,12)","min":"\nlet g2 () = (3, 66, 12);;\n","type":"","out":""},{"in":"let g3 () = (10,88,9)","min":"\nlet g3 () = (10, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (11,100,11)","min":"\nlet c2 () = (11, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"","type":"type","out":"Error: This expression has type expr/2609\n       but an expression was expected of type expr/3959\nError: This variant pattern is expected to have type expr\n       The constructor Mean3 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/2609\n       but an expression was expected of type expr/3959\n"},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"","type":"type","out":"Error: This expression has type expr/2609\n       but an expression was expected of type expr/3959\nError: This variant pattern is expected to have type expr\n       The constructor Mean3 does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 216-218:\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n                                                      ^^\nError: This expression has type expr/2609\n       but an expression was expected of type expr/3959\n"},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let _=eval(sampleExpr,0.5,0.2)","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,8) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildCube(build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","let g1 () = (5,91,13)","let g2 () = (3,66,12)","let g3 () = (10,88,9)","let c1 () = (8,90,10)","let c2 () = (11,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":6039,"stop":16951},"type":"eval"},"cursor":6381,"time":1.445057179319554e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildCube(build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,8) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 8) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n","type":"","out":""},{"in":"let g1 () = (5,91,13)","min":"\nlet g1 () = (5, 91, 13);;\n","type":"","out":""},{"in":"let g2 () = (3,66,12)","min":"\nlet g2 () = (3, 66, 12);;\n","type":"","out":""},{"in":"let g3 () = (10,88,9)","min":"\nlet g3 () = (10, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (11,100,11)","min":"\nlet c2 () = (11, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 8) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 8) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,8) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","let g1 () = (5,91,13)","let g2 () = (3,66,12)","let g3 () = (10,88,9)","let c1 () = (8,90,10)","let c2 () = (11,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":6600,"stop":16992},"type":"eval"},"cursor":7425,"time":1.445057248544413e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,8) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n","type":"","out":""},{"in":"let g1 () = (5,91,13)","min":"\nlet g1 () = (5, 91, 13);;\n","type":"","out":""},{"in":"let g2 () = (3,66,12)","min":"\nlet g2 () = (3, 66, 12);;\n","type":"","out":""},{"in":"let g3 () = (10,88,9)","min":"\nlet g3 () = (10, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (11,100,11)","min":"\nlet c2 () = (11, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","let g1 () = (5,91,13)","let g2 () = (3,66,12)","let g3 () = (10,88,9)","let c1 () = (8,90,10)","let c2 () = (11,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":6600,"stop":16992},"type":"eval"},"cursor":7062,"time":1.445057321866938e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"event":{"type":"abort"},"cursor":7062,"time":1.445057431004895e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,13)\nlet g2 () = (3,66,12)  \nlet g3 () = (10,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (11,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""},{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ =collatz 2","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 2;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Mean3    of expr * expr * expr \n| Square   of expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1,0.9,0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.9, 0.5);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let _=eval(sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n","type":"","out":""},{"in":"let g1 () = (5,91,8)","min":"\nlet g1 () = (5, 91, 8);;\n","type":"","out":""},{"in":"let g2 () = (3,66,12)","min":"\nlet g2 () = (3, 66, 12);;\n","type":"","out":""},{"in":"let g3 () = (4,88,9)","min":"\nlet g3 () = (4, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (5,100,11)","min":"\nlet c2 () = (5, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ =collatz 2","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Mean3    of expr * expr * expr \n| Square   of expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1,0.9,0.5)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let _=eval(sampleExpr,0.5,0.2)","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","let g1 () = (5,91,8)","let g2 () = (3,66,12)","let g3 () = (4,88,9)","let c1 () = (8,90,10)","let c2 () = (5,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":0,"stop":16989},"type":"eval"},"cursor":7806,"time":1.445057694439308e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (4,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (5,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g3 () = (12,88,9)","min":"\nlet g3 () = (12, 88, 9);;\n","type":"","out":""}],"event":{"phrases":["","let g3 () = (12,88,9)"],"region":{"start":7713,"stop":7737},"type":"eval"},"cursor":7731,"time":1.445057750324369e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (12,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (5,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g3 () = (12,88,9)","min":"\nlet g3 () = (12, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (5,100,11)","min":"\nlet c2 () = (5, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let g3 () = (12,88,9)","let c1 () = (8,90,10)","let c2 () = (5,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7716,"stop":16990},"type":"eval"},"cursor":7731,"time":1.445057756720439e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (12,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (5,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g3 () = (8,88,9)","min":"\nlet g3 () = (8, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (1,90,10)","min":"\nlet c1 () = (1, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (12,100,11)","min":"\nlet c2 () = (12, 100, 11);;\n","type":"","out":""}],"event":{"phrases":["","let g3 () = (8,88,9)","let c1 () = (1,90,10)","let c2 () = (12,100,11)"],"region":{"start":7713,"stop":7784},"type":"eval"},"cursor":7776,"time":1.44505793636994e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (8,88,9) \n\nlet c1 () = (1,90,10)\nlet c2 () = (12,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let c2 () = (12,100,11)","min":"\nlet c2 () = (12, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let c2 () = (12,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7761,"stop":16990},"type":"eval"},"cursor":7776,"time":1.44505793991089e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (8,88,9) \n\nlet c1 () = (1,90,10)\nlet c2 () = (12,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (name,age)::l' -> if k = name then age else assoc (d, k, l');;\n\nlet _ = assoc ([(1, 1)], \"a\", [(\"ca\", [(1, 2)]); (\"aa\", [(2, 2)])]);;\n","type":"","out":""},{"in":"let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet rec filter l h =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd = h then filter tl h else hd :: (filter tl h);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ =collatz 2","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = collatz 2;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (x, false) else ((f2 x), true) in\n  wwhile ((f1 f), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Mean3    of expr * expr * expr \n| Square   of expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n","type":"","out":""},{"in":"let buildSquare(e)\t\t   = Square(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildSquare e = Square e;;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.0, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ =eval(sampleExpr1,0.9,0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times\n         ((Sine (Mean3 (VarX, VarX, VarY))),\n           (Cosine (Average ((Square VarX), VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.9, 0.5);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let _=eval(sampleExpr,0.5,0.2)","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n","type":"","out":""},{"in":"let g1 () = (5,91,8)","min":"\nlet g1 () = (5, 91, 8);;\n","type":"","out":""},{"in":"let g2 () = (3,66,12)","min":"\nlet g2 () = (3, 66, 12);;\n","type":"","out":""},{"in":"let g3 () = (3,88,9)","min":"\nlet g3 () = (3, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (2,100,11)","min":"\nlet c2 () = (2, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec assoc (d,k,l) = \nmatch l with\n|[]->d\n|(name, age)::l'->if k=name then age\nelse assoc(d,k,l')","let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","let _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])","let rec filter l h=\nmatch l with\n[]->[]\n|hd::tl -> if hd=h then (filter tl h)\nelse hd::(filter tl h)","let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = (filter t h) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","let rec wwhile (f,b) = \nlet (b',c')=f b in \nif c'=true then wwhile(f,b')\nelse b'","let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","let fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)","let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","let _ =collatz 2","let _ = fixpoint (collatz, 1)","let _ = fixpoint (collatz, 3)","let _ = fixpoint (collatz, 48)","let _ = fixpoint (collatz, 107)","let _ = fixpoint (collatz, 9001)","type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Mean3    of expr * expr * expr \n| Square   of expr","let rec exprToString e = \nmatch e with\n|Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n|VarX\t\t ->\"x\"\n|VarY\t\t ->\"y\"\n|Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n|Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n|Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n|Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n|Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n|Square(e)\t ->\"(\"^(exprToString e)^\")^2\"","let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))","let _ = exprToString sampleExpr1","let buildX()                       = VarX","let buildY()                       = VarY","let buildSine(e)                   = Sine(e)","let buildCosine(e)                 = Cosine(e)","let buildAverage(e1,e2)            = Average(e1,e2)","let buildTimes(e1,e2)              = Times(e1,e2)","let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","let buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)","let buildSquare(e)\t\t   = Square(e)","let pi = 4.0 *. atan 1.0","let rec eval (e,x,y) = \nmatch e with \n|VarX ->x\n|VarY ->y\n|Sine(a)->sin(pi*.eval(a,x,y))\n|Cosine(a)->cos(pi*.eval(a,x,y))\n|Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n|Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n|Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n|Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n|Square(a)->let tempp=eval(a,x,y) in tempp*.tempp","let _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5)","let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","let _ =eval(sampleExpr1,0.9,0.5)","let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","let _=eval(sampleExpr,0.5,0.2)","let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|1->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|6->buildSquare(build(rand,depth-1))","let g1 () = (5,91,8)","let g2 () = (3,66,12)","let g3 () = (3,88,9)","let c1 () = (8,90,10)","let c2 () = (2,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":0,"stop":16989},"type":"eval"},"cursor":7775,"time":1.445058336270432e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |1->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |6->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (3,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (2,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|_->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_->buildSquare(build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | _ -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildSquare (build (rand, (depth - 1))));;\n","type":"","out":""},{"in":"let g1 () = (5,91,8)","min":"\nlet g1 () = (5, 91, 8);;\n","type":"","out":""},{"in":"let g2 () = (3,66,12)","min":"\nlet g2 () = (3, 66, 12);;\n","type":"","out":""},{"in":"let g3 () = (0,88,9)","min":"\nlet g3 () = (0, 88, 9);;\n","type":"","out":""}],"event":{"phrases":["","let rec build (rand, depth) = \nmatch depth with\n|0->(match rand(0,1) with\n|0->VarX\n|_->VarY)\n|n-> match rand(0,6) with\n|0->buildSine(build(rand,depth-1))\n|1->buildCosine(build(rand,depth-1))\n|2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_->buildSquare(build(rand,depth-1))","let g1 () = (5,91,8)","let g2 () = (3,66,12)","let g3 () = (0,88,9)"],"region":{"start":6600,"stop":7736},"type":"eval"},"cursor":7730,"time":1.445058500406903e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |_->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |_->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (0,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (2,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g3 () = (0,88,9)","min":"\nlet g3 () = (0, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (2,100,11)","min":"\nlet c2 () = (2, 100, 11);;\n","type":"","out":""},{"in":"let c3 () = (2,222,12)","min":"\nlet c3 () = (2, 222, 12);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | _ -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y)\n  | Mean3 (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) /. 3.0\n  | Square a -> let tempp = eval (a, x, y) in tempp *. tempp;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mean3 of expr* expr* expr\n  | Square of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMean3 (e1,e2,e3) = Mean3 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | _ -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildMean3\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Mean3 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/2\")))))\n  | Square e -> \"(\" ^ ((exprToString e) ^ \")^2\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let g3 () = (0,88,9)","let c1 () = (8,90,10)","let c2 () = (2,100,11)","let c3 () = (2,222,12)","let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","let toReal (i,n) = (float_of_int i) /. (float_of_int n)","let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","type test = unit -> string","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let sampleTests =\n[\n(fun () -> mkTest\nassoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n23\n\"sample: assoc 1\"\n);\n(fun () -> mkTest \nassoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n(-1)\n\"sample: assoc 2\"\n); \n(fun () -> mkTest \nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]\n\"sample: removeDuplicates 2\"\n);\n(fun () -> mkTest \nremoveDuplicates\n[1;1;1]\n[1]\n\"sample: removeDuplicates 2\"\n);\n\n(fun () -> mkTest \nwwhile \n((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n512 \n\"sample: wwhile 1\"\n); \n(fun () -> mkTest \nfixpoint\n((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n739085\n\"sample: fixpoint 1\"\n); \n\n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr, 150,\"sample\")\n()\n\"sample: eval_fn 1: manual\"\n); \n(fun () -> mkTest \nemitGrayscale\n(eval_fn sampleExpr2, 150,\"sample2\")\n()\n\"sample: eval_fn 2: manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomGray (g1 ()))\n()\n()\n\"sample: gray 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g2 ()))\n()\n()\n\"sample: gray 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomGray (g3 ()))\n()\n()\n\"sample: gray 3 : manual\"\n);\n\n(fun () -> mkTest \n(fun () -> doRandomColor (c1 ()))\n()\n()\n\"sample: color 1 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c2 ()))\n()\n()\n\"sample: color 2 : manual\"\n);\n(fun () -> mkTest \n(fun () -> doRandomColor (c3 ()))\n()\n()\n\"sample: color 3 : manual\"\n)]","let doTest f = \ntry f () with ex -> \nFormat.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let _ =\nlet report = List.map doTest sampleTests                in\nlet _      = List.iter print130 (report@([scoreMsg()])) in\nlet _      = print130 (\"Compiled\\n\")                    in\n(!score, !max)"],"region":{"start":7716,"stop":16989},"type":"eval"},"cursor":7730,"time":1.445058504505998e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |_->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |_->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (0,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (2,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let g3 () = (8,88,9)","min":"\nlet g3 () = (8, 88, 9);;\n","type":"","out":""},{"in":"let c1 () = (8,90,10)","min":"\nlet c1 () = (8, 90, 10);;\n","type":"","out":""},{"in":"let c2 () = (2,100,11)","min":"\nlet c2 () = (2, 100, 11);;\n","type":"","out":""}],"event":{"phrases":["","let g3 () = (8,88,9)","let c1 () = (8,90,10)","let c2 () = (2,100,11)"],"region":{"start":7713,"stop":7783},"type":"eval"},"cursor":7783,"time":1.445058587924148e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec assoc (d,k,l) = \n  match l with\n    |[]->d\n    |(name, age)::l'->if k=name then age\n        else assoc(d,k,l')\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\nlet _ = assoc([1,1],\"a\",[(\"ca\",[1,2]);(\"aa\",[2,2])])\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec filter l h=\n  match l with\n      []->[]\n    |hd::tl -> if hd=h then (filter tl h)\n        else hd::(filter tl h)\n;;\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' = h::seen in\n          let rest' = (filter t h) in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  let (b',c')=f b in \n    if c'=true then wwhile(f,b')\n    else b'\n;;\n\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet fixpoint (f,b) = let f1 f2 x= if (f2 x)=x then (x,false) else (f2 x,true) in wwhile ((f1 f),b)\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ =collatz 2;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Mean3    of expr * expr * expr \n    | Square   of expr\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX*)\nlet rec exprToString e = \n  match e with\n    |Thresh(a,b,c,d) ->\"(\"^exprToString a^\"<\"^exprToString b^\"?\"^exprToString c^\":\"^(exprToString d)^\")\"\n    |VarX\t\t ->\"x\"\n    |VarY\t\t ->\"y\"\n    |Sine(x)\t ->\"sin(pi*\"^(exprToString x)^\")\"\n    |Cosine(x)       ->\"cos(pi*\"^(exprToString x)^\")\"\n    |Average(e1,e2)  -> \"(\"^(exprToString e1) ^\"+\"^(exprToString e2)^\")/2\"\n    |Times(e1,e2)    ->(exprToString e1)^\"*\"^(exprToString e2)\n    |Mean3(e1,e2,e3)     ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\"+\"^(exprToString e3)^\")/2\"\n    |Square(e)\t ->\"(\"^(exprToString e)^\")^2\"\n;;\n\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Mean3(VarX,VarX,VarY)),Cosine(Average(Square(VarX),VarY)))))\n\nlet _ = exprToString sampleExpr1 \n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildMean3(e1,e2,e3)\t   = Mean3(e1,e2,e3)\nlet buildSquare(e)\t\t   = Square(e)\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n    |VarX ->x\n    |VarY ->y\n    |Sine(a)->sin(pi*.eval(a,x,y))\n    |Cosine(a)->cos(pi*.eval(a,x,y))\n    |Average(a,b)->(eval(a,x,y)+.eval(b,x,y))/.2.0\n    |Times(a,b)->eval(a,x,y)*.eval(b,x,y)\n    |Thresh(a,b,a_less,b_less)->let x1=eval(a,x,y) in let x2=eval(b,x,y)  in  if(x1<x2) then eval(a_less,x,y) else eval( b_less,x,y)\n    |Mean3(a,b,c)->(eval(a,x,y)+.eval(b,x,y)+.eval(c,x,y))/.3.0\n    |Square(a)->let tempp=eval(a,x,y) in tempp*.tempp\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.0,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ =eval(sampleExpr1,0.9,0.5)\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\nlet _=eval(sampleExpr,0.5,0.2)\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  match depth with\n    |0->(match rand(0,1) with\n          |0->VarX\n          |_->VarY)\n    |n-> match rand(0,6) with\n      |0->buildSine(build(rand,depth-1))\n      |1->buildCosine(build(rand,depth-1))\n      |2->buildAverage(build(rand,depth-1),build(rand,depth-1))\n      |3->buildTimes(build(rand,depth-1),build(rand,depth-1))\n      |4->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |5->buildMean3(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n      |_->buildSquare(build(rand,depth-1))\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (5,91,8)\nlet g2 () = (3,66,12)  \nlet g3 () = (8,88,9) \n\nlet c1 () = (8,90,10)\nlet c2 () = (2,100,11)\nlet c3 () = (2,222,12)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
